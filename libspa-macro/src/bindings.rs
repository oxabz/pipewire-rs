/* automatically generated by rust-bindgen 0.64.0 */

pub const SPA_NSEC_PER_SEC: u32 = 1000000000;
pub const SPA_NSEC_PER_MSEC: u32 = 1000000;
pub const SPA_NSEC_PER_USEC: u32 = 1000;
pub const SPA_USEC_PER_SEC: u32 = 1000000;
pub const SPA_USEC_PER_MSEC: u32 = 1000;
pub const SPA_MSEC_PER_SEC: u32 = 1000;
pub const SPA_TYPE_INFO_BASE: &[u8; 5usize] = b"Spa:\0";
pub const SPA_TYPE_INFO_Flags: &[u8; 10usize] = b"Spa:Flags\0";
pub const SPA_TYPE_INFO_FLAGS_BASE: &[u8; 11usize] = b"Spa:Flags:\0";
pub const SPA_TYPE_INFO_Enum: &[u8; 9usize] = b"Spa:Enum\0";
pub const SPA_TYPE_INFO_ENUM_BASE: &[u8; 10usize] = b"Spa:Enum:\0";
pub const SPA_TYPE_INFO_Pod: &[u8; 8usize] = b"Spa:Pod\0";
pub const SPA_TYPE_INFO_POD_BASE: &[u8; 9usize] = b"Spa:Pod:\0";
pub const SPA_TYPE_INFO_Struct: &[u8; 15usize] = b"Spa:Pod:Struct\0";
pub const SPA_TYPE_INFO_STRUCT_BASE: &[u8; 16usize] = b"Spa:Pod:Struct:\0";
pub const SPA_TYPE_INFO_Object: &[u8; 15usize] = b"Spa:Pod:Object\0";
pub const SPA_TYPE_INFO_OBJECT_BASE: &[u8; 16usize] = b"Spa:Pod:Object:\0";
pub const SPA_TYPE_INFO_Pointer: &[u8; 12usize] = b"Spa:Pointer\0";
pub const SPA_TYPE_INFO_POINTER_BASE: &[u8; 13usize] = b"Spa:Pointer:\0";
pub const SPA_TYPE_INFO_Interface: &[u8; 22usize] = b"Spa:Pointer:Interface\0";
pub const SPA_TYPE_INFO_INTERFACE_BASE: &[u8; 23usize] = b"Spa:Pointer:Interface:\0";
pub const SPA_TYPE_INFO_Event: &[u8; 21usize] = b"Spa:Pod:Object:Event\0";
pub const SPA_TYPE_INFO_EVENT_BASE: &[u8; 22usize] = b"Spa:Pod:Object:Event:\0";
pub const SPA_TYPE_INFO_Command: &[u8; 23usize] = b"Spa:Pod:Object:Command\0";
pub const SPA_TYPE_INFO_COMMAND_BASE: &[u8; 24usize] = b"Spa:Pod:Object:Command:\0";
pub const SPA_POD_PROP_FLAG_READONLY: u32 = 1;
pub const SPA_POD_PROP_FLAG_HARDWARE: u32 = 2;
pub const SPA_POD_PROP_FLAG_HINT_DICT: u32 = 4;
pub const SPA_POD_PROP_FLAG_MANDATORY: u32 = 8;
pub const SPA_POD_PROP_FLAG_DONT_FIXATE: u32 = 16;
pub const SPA_META_HEADER_FLAG_DISCONT: u32 = 1;
pub const SPA_META_HEADER_FLAG_CORRUPTED: u32 = 2;
pub const SPA_META_HEADER_FLAG_MARKER: u32 = 4;
pub const SPA_META_HEADER_FLAG_HEADER: u32 = 8;
pub const SPA_META_HEADER_FLAG_GAP: u32 = 16;
pub const SPA_META_HEADER_FLAG_DELTA_UNIT: u32 = 32;
pub const SPA_CHUNK_FLAG_NONE: u32 = 0;
pub const SPA_CHUNK_FLAG_CORRUPTED: u32 = 1;
pub const SPA_CHUNK_FLAG_EMPTY: u32 = 2;
pub const SPA_DATA_FLAG_NONE: u32 = 0;
pub const SPA_DATA_FLAG_READABLE: u32 = 1;
pub const SPA_DATA_FLAG_WRITABLE: u32 = 2;
pub const SPA_DATA_FLAG_DYNAMIC: u32 = 4;
pub const SPA_DATA_FLAG_READWRITE: u32 = 3;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_META: u32 = 1;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_CHUNK: u32 = 2;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_DATA: u32 = 4;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_ALL: u32 = 7;
pub const SPA_BUFFER_ALLOC_FLAG_NO_DATA: u32 = 8;
pub const SPA_TYPE_INFO_Buffer: &[u8; 19usize] = b"Spa:Pointer:Buffer\0";
pub const SPA_TYPE_INFO_BUFFER_BASE: &[u8; 20usize] = b"Spa:Pointer:Buffer:\0";
pub const SPA_TYPE_INFO_Data: &[u8; 14usize] = b"Spa:Enum:Data\0";
pub const SPA_TYPE_INFO_DATA_BASE: &[u8; 15usize] = b"Spa:Enum:Data:\0";
pub const SPA_TYPE_INFO_DATA_Fd: &[u8; 17usize] = b"Spa:Enum:Data:Fd\0";
pub const SPA_TYPE_INFO_DATA_FD_BASE: &[u8; 18usize] = b"Spa:Enum:Data:Fd:\0";
pub const SPA_TYPE_INFO_Meta: &[u8; 17usize] = b"Spa:Pointer:Meta\0";
pub const SPA_TYPE_INFO_META_BASE: &[u8; 18usize] = b"Spa:Pointer:Meta:\0";
pub const SPA_TYPE_INFO_META_Array: &[u8; 23usize] = b"Spa:Pointer:Meta:Array\0";
pub const SPA_TYPE_INFO_META_ARRAY_BASE: &[u8; 24usize] = b"Spa:Pointer:Meta:Array:\0";
pub const SPA_TYPE_INFO_META_Region: &[u8; 24usize] = b"Spa:Pointer:Meta:Region\0";
pub const SPA_TYPE_INFO_META_REGION_BASE: &[u8; 25usize] = b"Spa:Pointer:Meta:Region:\0";
pub const SPA_TYPE_INFO_META_ARRAY_Region: &[u8; 30usize] = b"Spa:Pointer:Meta:Array:Region\0";
pub const SPA_TYPE_INFO_META_ARRAY_REGION_BASE: &[u8; 31usize] =
    b"Spa:Pointer:Meta:Array:Region:\0";
pub const SPA_TYPE_INFO_Direction: &[u8; 19usize] = b"Spa:Enum:Direction\0";
pub const SPA_TYPE_INFO_DIRECTION_BASE: &[u8; 20usize] = b"Spa:Enum:Direction:\0";
pub const SPA_TYPE_INFO_Choice: &[u8; 16usize] = b"Spa:Enum:Choice\0";
pub const SPA_TYPE_INFO_CHOICE_BASE: &[u8; 17usize] = b"Spa:Enum:Choice:\0";
pub const SPA_TYPE_INFO_DeviceEvent: &[u8; 28usize] = b"Spa:Pod:Object:Event:Device\0";
pub const SPA_TYPE_INFO_DEVICE_EVENT_BASE: &[u8; 29usize] = b"Spa:Pod:Object:Event:Device:\0";
pub const SPA_TYPE_INFO_DeviceEventId: &[u8; 23usize] = b"Spa:Enum:DeviceEventId\0";
pub const SPA_TYPE_INFO_DEVICE_EVENT_ID_BASE: &[u8; 24usize] = b"Spa:Enum:DeviceEventId:\0";
pub const SPA_STATUS_OK: u32 = 0;
pub const SPA_STATUS_NEED_DATA: u32 = 1;
pub const SPA_STATUS_HAVE_DATA: u32 = 2;
pub const SPA_STATUS_STOPPED: u32 = 4;
pub const SPA_STATUS_DRAINED: u32 = 8;
pub const SPA_IO_CLOCK_FLAG_FREEWHEEL: u32 = 1;
pub const SPA_IO_VIDEO_SIZE_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_BAR_FLAG_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_DROP_FRAME: u32 = 2;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_PULL_DOWN: u32 = 4;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_INTERLACED: u32 = 8;
pub const SPA_IO_SEGMENT_FLAG_LOOPING: u32 = 1;
pub const SPA_IO_SEGMENT_FLAG_NO_POSITION: u32 = 2;
pub const SPA_IO_POSITION_MAX_SEGMENTS: u32 = 8;
pub const SPA_IO_RATE_MATCH_FLAG_ACTIVE: u32 = 1;
pub const SPA_TYPE_INFO_IO: &[u8; 12usize] = b"Spa:Enum:IO\0";
pub const SPA_TYPE_INFO_IO_BASE: &[u8; 13usize] = b"Spa:Enum:IO:\0";
pub const SPA_TYPE_INFO_NodeEvent: &[u8; 26usize] = b"Spa:Pod:Object:Event:Node\0";
pub const SPA_TYPE_INFO_NODE_EVENT_BASE: &[u8; 27usize] = b"Spa:Pod:Object:Event:Node:\0";
pub const SPA_TYPE_INFO_NodeCommand: &[u8; 28usize] = b"Spa:Pod:Object:Command:Node\0";
pub const SPA_TYPE_INFO_NODE_COMMAND_BASE: &[u8; 29usize] = b"Spa:Pod:Object:Command:Node:\0";
pub const SPA_PARAM_INFO_SERIAL: u32 = 1;
pub const SPA_PARAM_INFO_READ: u32 = 2;
pub const SPA_PARAM_INFO_WRITE: u32 = 4;
pub const SPA_PARAM_INFO_READWRITE: u32 = 6;
pub const SPA_KEY_FORMAT_DSP: &[u8; 11usize] = b"format.dsp\0";
pub const SPA_TYPE_INFO_ParamId: &[u8; 17usize] = b"Spa:Enum:ParamId\0";
pub const SPA_TYPE_INFO_PARAM_ID_BASE: &[u8; 18usize] = b"Spa:Enum:ParamId:\0";
pub const SPA_TYPE_INFO_Param: &[u8; 21usize] = b"Spa:Pod:Object:Param\0";
pub const SPA_TYPE_INFO_PARAM_BASE: &[u8; 22usize] = b"Spa:Pod:Object:Param:\0";
pub const SPA_AUDIO_MAX_CHANNELS: u32 = 64;
pub const SPA_AUDIO_FLAG_NONE: u32 = 0;
pub const SPA_AUDIO_FLAG_UNPOSITIONED: u32 = 1;
pub const SPA_KEY_AUDIO_FORMAT: &[u8; 13usize] = b"audio.format\0";
pub const SPA_KEY_AUDIO_CHANNEL: &[u8; 14usize] = b"audio.channel\0";
pub const SPA_KEY_AUDIO_CHANNELS: &[u8; 15usize] = b"audio.channels\0";
pub const SPA_KEY_AUDIO_RATE: &[u8; 11usize] = b"audio.rate\0";
pub const SPA_KEY_AUDIO_POSITION: &[u8; 15usize] = b"audio.position\0";
pub const SPA_KEY_AUDIO_ALLOWED_RATES: &[u8; 20usize] = b"audio.allowed-rates\0";
pub const SPA_TYPE_INFO_AudioFormat: &[u8; 21usize] = b"Spa:Enum:AudioFormat\0";
pub const SPA_TYPE_INFO_AUDIO_FORMAT_BASE: &[u8; 22usize] = b"Spa:Enum:AudioFormat:\0";
pub const SPA_TYPE_INFO_AudioFlags: &[u8; 21usize] = b"Spa:Flags:AudioFlags\0";
pub const SPA_TYPE_INFO_AUDIO_FLAGS_BASE: &[u8; 22usize] = b"Spa:Flags:AudioFlags:\0";
pub const SPA_TYPE_INFO_AudioChannel: &[u8; 22usize] = b"Spa:Enum:AudioChannel\0";
pub const SPA_TYPE_INFO_AUDIO_CHANNEL_BASE: &[u8; 23usize] = b"Spa:Enum:AudioChannel:\0";
pub const SPA_TYPE_INFO_AudioIEC958Codec: &[u8; 26usize] = b"Spa:Enum:AudioIEC958Codec\0";
pub const SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE: &[u8; 27usize] = b"Spa:Enum:AudioIEC958Codec:\0";
pub const SPA_TYPE_INFO_AudioMP3ChannelMode: &[u8; 29usize] = b"Spa:Enum:AudioMP3ChannelMode\0";
pub const SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE: &[u8; 30usize] =
    b"Spa:Enum:AudioMP3ChannelMode:\0";
pub const SPA_TYPE_INFO_AudioAACStreamFormat: &[u8; 30usize] = b"Spa:Enum:AudioAACStreamFormat\0";
pub const SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE: &[u8; 31usize] =
    b"Spa:Enum:AudioAACStreamFormat:\0";
pub const SPA_TYPE_INFO_AudioWMAProfile: &[u8; 25usize] = b"Spa:Enum:AudioWMAProfile\0";
pub const SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE: &[u8; 26usize] = b"Spa:Enum:AudioWMAProfile:\0";
pub const SPA_TYPE_INFO_AudioAMRBandMode: &[u8; 26usize] = b"Spa:Enum:AudioAMRBandMode\0";
pub const SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE: &[u8; 27usize] = b"Spa:Enum:AudioAMRBandMode:\0";
pub const SPA_TYPE_INFO_ParamBitorder: &[u8; 23usize] = b"Spa:Enum:ParamBitorder\0";
pub const SPA_TYPE_INFO_PARAM_BITORDER_BASE: &[u8; 24usize] = b"Spa:Enum:ParamBitorder:\0";
pub const SPA_TYPE_INFO_ParamAvailability: &[u8; 27usize] = b"Spa:Enum:ParamAvailability\0";
pub const SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE: &[u8; 28usize] = b"Spa:Enum:ParamAvailability:\0";
pub const SPA_TYPE_INFO_PARAM_Meta: &[u8; 26usize] = b"Spa:Pod:Object:Param:Meta\0";
pub const SPA_TYPE_INFO_PARAM_META_BASE: &[u8; 27usize] = b"Spa:Pod:Object:Param:Meta:\0";
pub const SPA_TYPE_INFO_PARAM_IO: &[u8; 24usize] = b"Spa:Pod:Object:Param:IO\0";
pub const SPA_TYPE_INFO_PARAM_IO_BASE: &[u8; 25usize] = b"Spa:Pod:Object:Param:IO:\0";
pub const SPA_TYPE_INFO_PARAM_Buffers: &[u8; 29usize] = b"Spa:Pod:Object:Param:Buffers\0";
pub const SPA_TYPE_INFO_PARAM_BUFFERS_BASE: &[u8; 30usize] = b"Spa:Pod:Object:Param:Buffers:\0";
pub const SPA_TYPE_INFO_PARAM_BlockInfo: &[u8; 39usize] =
    b"Spa:Pod:Object:Param:Buffers:BlockInfo\0";
pub const SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE: &[u8; 40usize] =
    b"Spa:Pod:Object:Param:Buffers:BlockInfo:\0";
pub const SPA_TYPE_INFO_BluetoothAudioCodec: &[u8; 29usize] = b"Spa:Enum:BluetoothAudioCodec\0";
pub const SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE: &[u8; 30usize] =
    b"Spa:Enum:BluetoothAudioCodec:\0";
pub const SPA_TYPE_INFO_Props: &[u8; 27usize] = b"Spa:Pod:Object:Param:Props\0";
pub const SPA_TYPE_INFO_PROPS_BASE: &[u8; 28usize] = b"Spa:Pod:Object:Param:Props:\0";
pub const SPA_TYPE_INFO_PropInfo: &[u8; 30usize] = b"Spa:Pod:Object:Param:PropInfo\0";
pub const SPA_TYPE_INFO_PROP_INFO_BASE: &[u8; 31usize] = b"Spa:Pod:Object:Param:PropInfo:\0";
pub const SPA_VIDEO_MAX_PLANES: u32 = 4;
pub const SPA_VIDEO_MAX_COMPONENTS: u32 = 4;
pub const SPA_TYPE_INFO_VideoFormat: &[u8; 21usize] = b"Spa:Enum:VideoFormat\0";
pub const SPA_TYPE_INFO_VIDEO_FORMAT_BASE: &[u8; 22usize] = b"Spa:Enum:VideoFormat:\0";
pub const SPA_TYPE_INFO_VideoFlags: &[u8; 21usize] = b"Spa:Flags:VideoFlags\0";
pub const SPA_TYPE_INFO_VIDEO_FLAGS_BASE: &[u8; 22usize] = b"Spa:Flags:VideoFlags:\0";
pub const SPA_TYPE_INFO_VideoInterlaceMode: &[u8; 28usize] = b"Spa:Enum:VideoInterlaceMode\0";
pub const SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE: &[u8; 29usize] =
    b"Spa:Enum:VideoInterlaceMode:\0";
pub const SPA_TYPE_INFO_Format: &[u8; 28usize] = b"Spa:Pod:Object:Param:Format\0";
pub const SPA_TYPE_INFO_FORMAT_BASE: &[u8; 29usize] = b"Spa:Pod:Object:Param:Format:\0";
pub const SPA_TYPE_INFO_MediaType: &[u8; 19usize] = b"Spa:Enum:MediaType\0";
pub const SPA_TYPE_INFO_MEDIA_TYPE_BASE: &[u8; 20usize] = b"Spa:Enum:MediaType:\0";
pub const SPA_TYPE_INFO_MediaSubtype: &[u8; 22usize] = b"Spa:Enum:MediaSubtype\0";
pub const SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE: &[u8; 23usize] = b"Spa:Enum:MediaSubtype:\0";
pub const SPA_TYPE_INFO_FormatAudio: &[u8; 34usize] = b"Spa:Pod:Object:Param:Format:Audio\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_BASE: &[u8; 35usize] = b"Spa:Pod:Object:Param:Format:Audio:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AAC: &[u8; 38usize] =
    b"Spa:Pod:Object:Param:Format:Audio:AAC\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AAC_BASE: &[u8; 39usize] =
    b"Spa:Pod:Object:Param:Format:Audio:AAC:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_WMA: &[u8; 38usize] =
    b"Spa:Pod:Object:Param:Format:Audio:WMA\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_WMA_BASE: &[u8; 39usize] =
    b"Spa:Pod:Object:Param:Format:Audio:WMA:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AMR: &[u8; 38usize] =
    b"Spa:Pod:Object:Param:Format:Audio:AMR\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AMR_BASE: &[u8; 39usize] =
    b"Spa:Pod:Object:Param:Format:Audio:AMR:\0";
pub const SPA_TYPE_INFO_FormatVideo: &[u8; 34usize] = b"Spa:Pod:Object:Param:Format:Video\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_BASE: &[u8; 35usize] = b"Spa:Pod:Object:Param:Format:Video:\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_H264: &[u8; 39usize] =
    b"Spa:Pod:Object:Param:Format:Video:H264\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE: &[u8; 40usize] =
    b"Spa:Pod:Object:Param:Format:Video:H264:\0";
pub const SPA_TYPE_INFO_PARAM_Latency: &[u8; 29usize] = b"Spa:Pod:Object:Param:Latency\0";
pub const SPA_TYPE_INFO_PARAM_LATENCY_BASE: &[u8; 30usize] = b"Spa:Pod:Object:Param:Latency:\0";
pub const SPA_TYPE_INFO_PARAM_ProcessLatency: &[u8; 36usize] =
    b"Spa:Pod:Object:Param:ProcessLatency\0";
pub const SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE: &[u8; 37usize] =
    b"Spa:Pod:Object:Param:ProcessLatency:\0";
pub const SPA_TYPE_INFO_ParamPortConfigMode: &[u8; 29usize] = b"Spa:Enum:ParamPortConfigMode\0";
pub const SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE: &[u8; 30usize] =
    b"Spa:Enum:ParamPortConfigMode:\0";
pub const SPA_TYPE_INFO_PARAM_PortConfig: &[u8; 32usize] = b"Spa:Pod:Object:Param:PortConfig\0";
pub const SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE: &[u8; 33usize] =
    b"Spa:Pod:Object:Param:PortConfig:\0";
pub const SPA_TYPE_INFO_Profiler: &[u8; 24usize] = b"Spa:Pod:Object:Profiler\0";
pub const SPA_TYPE_INFO_PROFILER_BASE: &[u8; 25usize] = b"Spa:Pod:Object:Profiler:\0";
pub const SPA_TYPE_INFO_PARAM_Profile: &[u8; 29usize] = b"Spa:Pod:Object:Param:Profile\0";
pub const SPA_TYPE_INFO_PARAM_PROFILE_BASE: &[u8; 30usize] = b"Spa:Pod:Object:Param:Profile:\0";
pub const SPA_TYPE_INFO_PARAM_Route: &[u8; 27usize] = b"Spa:Pod:Object:Param:Route\0";
pub const SPA_TYPE_INFO_PARAM_ROUTE_BASE: &[u8; 28usize] = b"Spa:Pod:Object:Param:Route:\0";
pub const SPA_TYPE_INFO_Control: &[u8; 17usize] = b"Spa:Enum:Control\0";
pub const SPA_TYPE_INFO_CONTROL_BASE: &[u8; 18usize] = b"Spa:Enum:Control:\0";
pub const SPA_DICT_FLAG_SORTED: u32 = 1;
pub const SPA_TYPE_INTERFACE_Node: &[u8; 27usize] = b"Spa:Pointer:Interface:Node\0";
pub const SPA_VERSION_NODE: u32 = 0;
pub const SPA_NODE_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_NODE_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_NODE_CHANGE_MASK_PARAMS: u32 = 4;
pub const SPA_NODE_FLAG_RT: u32 = 1;
pub const SPA_NODE_FLAG_IN_DYNAMIC_PORTS: u32 = 2;
pub const SPA_NODE_FLAG_OUT_DYNAMIC_PORTS: u32 = 4;
pub const SPA_NODE_FLAG_IN_PORT_CONFIG: u32 = 8;
pub const SPA_NODE_FLAG_OUT_PORT_CONFIG: u32 = 16;
pub const SPA_NODE_FLAG_NEED_CONFIGURE: u32 = 32;
pub const SPA_NODE_FLAG_ASYNC: u32 = 64;
pub const SPA_PORT_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_PORT_CHANGE_MASK_RATE: u32 = 2;
pub const SPA_PORT_CHANGE_MASK_PROPS: u32 = 4;
pub const SPA_PORT_CHANGE_MASK_PARAMS: u32 = 8;
pub const SPA_PORT_FLAG_REMOVABLE: u32 = 1;
pub const SPA_PORT_FLAG_OPTIONAL: u32 = 2;
pub const SPA_PORT_FLAG_CAN_ALLOC_BUFFERS: u32 = 4;
pub const SPA_PORT_FLAG_IN_PLACE: u32 = 8;
pub const SPA_PORT_FLAG_NO_REF: u32 = 16;
pub const SPA_PORT_FLAG_LIVE: u32 = 32;
pub const SPA_PORT_FLAG_PHYSICAL: u32 = 64;
pub const SPA_PORT_FLAG_TERMINAL: u32 = 128;
pub const SPA_PORT_FLAG_DYNAMIC_DATA: u32 = 256;
pub const SPA_RESULT_TYPE_NODE_ERROR: u32 = 1;
pub const SPA_RESULT_TYPE_NODE_PARAMS: u32 = 2;
pub const SPA_NODE_EVENT_INFO: u32 = 0;
pub const SPA_NODE_EVENT_PORT_INFO: u32 = 1;
pub const SPA_NODE_EVENT_RESULT: u32 = 2;
pub const SPA_NODE_EVENT_EVENT: u32 = 3;
pub const SPA_NODE_EVENT_NUM: u32 = 4;
pub const SPA_VERSION_NODE_EVENTS: u32 = 0;
pub const SPA_NODE_CALLBACK_READY: u32 = 0;
pub const SPA_NODE_CALLBACK_REUSE_BUFFER: u32 = 1;
pub const SPA_NODE_CALLBACK_XRUN: u32 = 2;
pub const SPA_NODE_CALLBACK_NUM: u32 = 3;
pub const SPA_VERSION_NODE_CALLBACKS: u32 = 0;
pub const SPA_NODE_PARAM_FLAG_TEST_ONLY: u32 = 1;
pub const SPA_NODE_PARAM_FLAG_FIXATE: u32 = 2;
pub const SPA_NODE_PARAM_FLAG_NEAREST: u32 = 4;
pub const SPA_NODE_BUFFERS_FLAG_ALLOC: u32 = 1;
pub const SPA_NODE_METHOD_ADD_LISTENER: u32 = 0;
pub const SPA_NODE_METHOD_SET_CALLBACKS: u32 = 1;
pub const SPA_NODE_METHOD_SYNC: u32 = 2;
pub const SPA_NODE_METHOD_ENUM_PARAMS: u32 = 3;
pub const SPA_NODE_METHOD_SET_PARAM: u32 = 4;
pub const SPA_NODE_METHOD_SET_IO: u32 = 5;
pub const SPA_NODE_METHOD_SEND_COMMAND: u32 = 6;
pub const SPA_NODE_METHOD_ADD_PORT: u32 = 7;
pub const SPA_NODE_METHOD_REMOVE_PORT: u32 = 8;
pub const SPA_NODE_METHOD_PORT_ENUM_PARAMS: u32 = 9;
pub const SPA_NODE_METHOD_PORT_SET_PARAM: u32 = 10;
pub const SPA_NODE_METHOD_PORT_USE_BUFFERS: u32 = 11;
pub const SPA_NODE_METHOD_PORT_SET_IO: u32 = 12;
pub const SPA_NODE_METHOD_PORT_REUSE_BUFFER: u32 = 13;
pub const SPA_NODE_METHOD_PROCESS: u32 = 14;
pub const SPA_NODE_METHOD_NUM: u32 = 15;
pub const SPA_VERSION_NODE_METHODS: u32 = 0;
pub const SPA_VERSION_GRAPH_NODE_CALLBACKS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Device: &[u8; 29usize] = b"Spa:Pointer:Interface:Device\0";
pub const SPA_VERSION_DEVICE: u32 = 0;
pub const SPA_VERSION_DEVICE_INFO: u32 = 0;
pub const SPA_DEVICE_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_DEVICE_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_DEVICE_CHANGE_MASK_PARAMS: u32 = 4;
pub const SPA_VERSION_DEVICE_OBJECT_INFO: u32 = 0;
pub const SPA_DEVICE_OBJECT_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_DEVICE_OBJECT_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_RESULT_TYPE_DEVICE_PARAMS: u32 = 1;
pub const SPA_DEVICE_EVENT_INFO: u32 = 0;
pub const SPA_DEVICE_EVENT_RESULT: u32 = 1;
pub const SPA_DEVICE_EVENT_EVENT: u32 = 2;
pub const SPA_DEVICE_EVENT_OBJECT_INFO: u32 = 3;
pub const SPA_DEVICE_EVENT_NUM: u32 = 4;
pub const SPA_VERSION_DEVICE_EVENTS: u32 = 0;
pub const SPA_DEVICE_METHOD_ADD_LISTENER: u32 = 0;
pub const SPA_DEVICE_METHOD_SYNC: u32 = 1;
pub const SPA_DEVICE_METHOD_ENUM_PARAMS: u32 = 2;
pub const SPA_DEVICE_METHOD_SET_PARAM: u32 = 3;
pub const SPA_DEVICE_METHOD_NUM: u32 = 4;
pub const SPA_VERSION_DEVICE_METHODS: u32 = 0;
pub const SPA_KEY_DEVICE_ENUM_API: &[u8; 16usize] = b"device.enum.api\0";
pub const SPA_KEY_DEVICE_API: &[u8; 11usize] = b"device.api\0";
pub const SPA_KEY_DEVICE_NAME: &[u8; 12usize] = b"device.name\0";
pub const SPA_KEY_DEVICE_ALIAS: &[u8; 13usize] = b"device.alias\0";
pub const SPA_KEY_DEVICE_NICK: &[u8; 12usize] = b"device.nick\0";
pub const SPA_KEY_DEVICE_DESCRIPTION: &[u8; 19usize] = b"device.description\0";
pub const SPA_KEY_DEVICE_ICON: &[u8; 12usize] = b"device.icon\0";
pub const SPA_KEY_DEVICE_ICON_NAME: &[u8; 17usize] = b"device.icon-name\0";
pub const SPA_KEY_DEVICE_PLUGGED_USEC: &[u8; 20usize] = b"device.plugged.usec\0";
pub const SPA_KEY_DEVICE_BUS_ID: &[u8; 14usize] = b"device.bus-id\0";
pub const SPA_KEY_DEVICE_BUS_PATH: &[u8; 16usize] = b"device.bus-path\0";
pub const SPA_KEY_DEVICE_BUS: &[u8; 11usize] = b"device.bus\0";
pub const SPA_KEY_DEVICE_SUBSYSTEM: &[u8; 17usize] = b"device.subsystem\0";
pub const SPA_KEY_DEVICE_SYSFS_PATH: &[u8; 18usize] = b"device.sysfs.path\0";
pub const SPA_KEY_DEVICE_VENDOR_ID: &[u8; 17usize] = b"device.vendor.id\0";
pub const SPA_KEY_DEVICE_VENDOR_NAME: &[u8; 19usize] = b"device.vendor.name\0";
pub const SPA_KEY_DEVICE_PRODUCT_ID: &[u8; 18usize] = b"device.product.id\0";
pub const SPA_KEY_DEVICE_PRODUCT_NAME: &[u8; 20usize] = b"device.product.name\0";
pub const SPA_KEY_DEVICE_SERIAL: &[u8; 14usize] = b"device.serial\0";
pub const SPA_KEY_DEVICE_CLASS: &[u8; 13usize] = b"device.class\0";
pub const SPA_KEY_DEVICE_CAPABILITIES: &[u8; 20usize] = b"device.capabilities\0";
pub const SPA_KEY_DEVICE_FORM_FACTOR: &[u8; 19usize] = b"device.form-factor\0";
pub const SPA_KEY_DEVICE_PROFILE: &[u8; 16usize] = b"device.profile\t\0";
pub const SPA_KEY_DEVICE_PROFILE_SET: &[u8; 19usize] = b"device.profile-set\0";
pub const SPA_KEY_DEVICE_STRING: &[u8; 14usize] = b"device.string\0";
pub const SPA_POD_BUILDER_FLAG_BODY: u32 = 1;
pub const SPA_POD_BUILDER_FLAG_FIRST: u32 = 2;
pub const SPA_VERSION_POD_BUILDER_CALLBACKS: u32 = 0;
pub const SPA_KEY_NODE_NAME: &[u8; 10usize] = b"node.name\0";
pub const SPA_KEY_NODE_LATENCY: &[u8; 13usize] = b"node.latency\0";
pub const SPA_KEY_NODE_MAX_LATENCY: &[u8; 17usize] = b"node.max-latency\0";
pub const SPA_KEY_NODE_DRIVER: &[u8; 12usize] = b"node.driver\0";
pub const SPA_KEY_NODE_ALWAYS_PROCESS: &[u8; 20usize] = b"node.always-process\0";
pub const SPA_KEY_NODE_PAUSE_ON_IDLE: &[u8; 19usize] = b"node.pause-on-idle\0";
pub const SPA_KEY_NODE_MONITOR: &[u8; 13usize] = b"node.monitor\0";
pub const SPA_KEY_PORT_NAME: &[u8; 10usize] = b"port.name\0";
pub const SPA_KEY_PORT_ALIAS: &[u8; 11usize] = b"port.alias\0";
pub const SPA_KEY_PORT_MONITOR: &[u8; 13usize] = b"port.monitor\0";
pub const SPA_AUDIO_DSD_FLAG_NONE: u32 = 0;
pub const SPA_TYPE_INTERFACE_CPU: &[u8; 26usize] = b"Spa:Pointer:Interface:CPU\0";
pub const SPA_VERSION_CPU: u32 = 0;
pub const SPA_CPU_FLAG_MMX: u32 = 1;
pub const SPA_CPU_FLAG_MMXEXT: u32 = 2;
pub const SPA_CPU_FLAG_3DNOW: u32 = 4;
pub const SPA_CPU_FLAG_SSE: u32 = 8;
pub const SPA_CPU_FLAG_SSE2: u32 = 16;
pub const SPA_CPU_FLAG_3DNOWEXT: u32 = 32;
pub const SPA_CPU_FLAG_SSE3: u32 = 64;
pub const SPA_CPU_FLAG_SSSE3: u32 = 128;
pub const SPA_CPU_FLAG_SSE41: u32 = 256;
pub const SPA_CPU_FLAG_SSE42: u32 = 512;
pub const SPA_CPU_FLAG_AESNI: u32 = 1024;
pub const SPA_CPU_FLAG_AVX: u32 = 2048;
pub const SPA_CPU_FLAG_XOP: u32 = 4096;
pub const SPA_CPU_FLAG_FMA4: u32 = 8192;
pub const SPA_CPU_FLAG_CMOV: u32 = 16384;
pub const SPA_CPU_FLAG_AVX2: u32 = 32768;
pub const SPA_CPU_FLAG_FMA3: u32 = 65536;
pub const SPA_CPU_FLAG_BMI1: u32 = 131072;
pub const SPA_CPU_FLAG_BMI2: u32 = 262144;
pub const SPA_CPU_FLAG_AVX512: u32 = 524288;
pub const SPA_CPU_FLAG_SLOW_UNALIGNED: u32 = 1048576;
pub const SPA_CPU_FLAG_ALTIVEC: u32 = 1;
pub const SPA_CPU_FLAG_VSX: u32 = 2;
pub const SPA_CPU_FLAG_POWER8: u32 = 4;
pub const SPA_CPU_FLAG_ARMV5TE: u32 = 1;
pub const SPA_CPU_FLAG_ARMV6: u32 = 2;
pub const SPA_CPU_FLAG_ARMV6T2: u32 = 4;
pub const SPA_CPU_FLAG_VFP: u32 = 8;
pub const SPA_CPU_FLAG_VFPV3: u32 = 16;
pub const SPA_CPU_FLAG_NEON: u32 = 32;
pub const SPA_CPU_FLAG_ARMV8: u32 = 64;
pub const SPA_CPU_VM_NONE: u32 = 0;
pub const SPA_CPU_VM_OTHER: u32 = 1;
pub const SPA_CPU_VM_KVM: u32 = 2;
pub const SPA_CPU_VM_QEMU: u32 = 4;
pub const SPA_CPU_VM_BOCHS: u32 = 8;
pub const SPA_CPU_VM_XEN: u32 = 16;
pub const SPA_CPU_VM_UML: u32 = 32;
pub const SPA_CPU_VM_VMWARE: u32 = 64;
pub const SPA_CPU_VM_ORACLE: u32 = 128;
pub const SPA_CPU_VM_MICROSOFT: u32 = 256;
pub const SPA_CPU_VM_ZVM: u32 = 512;
pub const SPA_CPU_VM_PARALLELS: u32 = 1024;
pub const SPA_CPU_VM_BHYVE: u32 = 2048;
pub const SPA_CPU_VM_QNX: u32 = 4096;
pub const SPA_CPU_VM_ACRN: u32 = 8192;
pub const SPA_CPU_VM_POWERVM: u32 = 16384;
pub const SPA_VERSION_CPU_METHODS: u32 = 2;
pub const SPA_KEY_CPU_FORCE: &[u8; 10usize] = b"cpu.force\0";
pub const SPA_KEY_CPU_VM_TYPE: &[u8; 12usize] = b"cpu.vm.type\0";
pub const SPA_KEY_CPU_ZERO_DENORMALS: &[u8; 19usize] = b"cpu.zero.denormals\0";
pub const SPA_TYPE_INTERFACE_System: &[u8; 29usize] = b"Spa:Pointer:Interface:System\0";
pub const SPA_TYPE_INTERFACE_DataSystem: &[u8; 33usize] = b"Spa:Pointer:Interface:DataSystem\0";
pub const SPA_VERSION_SYSTEM: u32 = 0;
pub const SPA_IO_IN: u32 = 1;
pub const SPA_IO_OUT: u32 = 4;
pub const SPA_IO_ERR: u32 = 8;
pub const SPA_IO_HUP: u32 = 16;
pub const SPA_FD_CLOEXEC: u32 = 1;
pub const SPA_FD_NONBLOCK: u32 = 2;
pub const SPA_FD_EVENT_SEMAPHORE: u32 = 4;
pub const SPA_FD_TIMER_ABSTIME: u32 = 8;
pub const SPA_FD_TIMER_CANCEL_ON_SET: u32 = 16;
pub const SPA_VERSION_SYSTEM_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Loop: &[u8; 27usize] = b"Spa:Pointer:Interface:Loop\0";
pub const SPA_TYPE_INTERFACE_DataLoop: &[u8; 31usize] = b"Spa:Pointer:Interface:DataLoop\0";
pub const SPA_VERSION_LOOP: u32 = 0;
pub const SPA_TYPE_INTERFACE_LoopControl: &[u8; 34usize] = b"Spa:Pointer:Interface:LoopControl\0";
pub const SPA_VERSION_LOOP_CONTROL: u32 = 1;
pub const SPA_TYPE_INTERFACE_LoopUtils: &[u8; 32usize] = b"Spa:Pointer:Interface:LoopUtils\0";
pub const SPA_VERSION_LOOP_UTILS: u32 = 0;
pub const SPA_VERSION_LOOP_METHODS: u32 = 0;
pub const SPA_VERSION_LOOP_CONTROL_HOOKS: u32 = 0;
pub const SPA_VERSION_LOOP_CONTROL_METHODS: u32 = 1;
pub const SPA_VERSION_LOOP_UTILS_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_DBus: &[u8; 27usize] = b"Spa:Pointer:Interface:DBus\0";
pub const SPA_VERSION_DBUS: u32 = 0;
pub const SPA_DBUS_CONNECTION_EVENT_DESTROY: u32 = 0;
pub const SPA_DBUS_CONNECTION_EVENT_DISCONNECTED: u32 = 1;
pub const SPA_DBUS_CONNECTION_EVENT_NUM: u32 = 2;
pub const SPA_VERSION_DBUS_CONNECTION_EVENTS: u32 = 0;
pub const SPA_VERSION_DBUS_CONNECTION: u32 = 1;
pub const SPA_VERSION_DBUS_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_I18N: &[u8; 27usize] = b"Spa:Pointer:Interface:I18N\0";
pub const SPA_VERSION_I18N: u32 = 0;
pub const SPA_VERSION_I18N_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Log: &[u8; 26usize] = b"Spa:Pointer:Interface:Log\0";
pub const SPA_VERSION_LOG: u32 = 0;
pub const SPA_VERSION_LOG_TOPIC: u32 = 0;
pub const SPA_VERSION_LOG_METHODS: u32 = 1;
pub const SPA_KEY_LOG_LEVEL: &[u8; 10usize] = b"log.level\0";
pub const SPA_KEY_LOG_COLORS: &[u8; 11usize] = b"log.colors\0";
pub const SPA_KEY_LOG_FILE: &[u8; 9usize] = b"log.file\0";
pub const SPA_KEY_LOG_TIMESTAMP: &[u8; 14usize] = b"log.timestamp\0";
pub const SPA_KEY_LOG_LINE: &[u8; 9usize] = b"log.line\0";
pub const SPA_KEY_LOG_PATTERNS: &[u8; 13usize] = b"log.patterns\0";
pub const SPA_TYPE_INTERFACE_PluginLoader: &[u8; 35usize] = b"Spa:Pointer:Interface:PluginLoader\0";
pub const SPA_VERSION_PLUGIN_LOADER: u32 = 0;
pub const SPA_VERSION_PLUGIN_LOADER_METHODS: u32 = 0;
pub const SPA_VERSION_HANDLE: u32 = 0;
pub const SPA_VERSION_HANDLE_FACTORY: u32 = 1;
pub const SPA_HANDLE_FACTORY_ENUM_FUNC_NAME: &[u8; 24usize] = b"spa_handle_factory_enum\0";
pub const SPA_KEY_FACTORY_NAME: &[u8; 13usize] = b"factory.name\0";
pub const SPA_KEY_FACTORY_AUTHOR: &[u8; 15usize] = b"factory.author\0";
pub const SPA_KEY_FACTORY_DESCRIPTION: &[u8; 20usize] = b"factory.description\0";
pub const SPA_KEY_FACTORY_USAGE: &[u8; 14usize] = b"factory.usage\0";
pub const SPA_KEY_LIBRARY_NAME: &[u8; 13usize] = b"library.name\0";
pub const SPA_TYPE_INFO_Thread: &[u8; 19usize] = b"Spa:Pointer:Thread\0";
pub const SPA_TYPE_INTERFACE_ThreadUtils: &[u8; 34usize] = b"Spa:Pointer:Interface:ThreadUtils\0";
pub const SPA_VERSION_THREAD_UTILS: u32 = 0;
pub const SPA_VERSION_THREAD_UTILS_METHODS: u32 = 0;
pub const SPA_KEY_THREAD_NAME: &[u8; 12usize] = b"thread.name\0";
pub const SPA_KEY_THREAD_STACK_SIZE: &[u8; 18usize] = b"thread.stack-size\0";
pub const SPA_ANSI_RESET: &[u8; 5usize] = b"\x1B[0m\0";
pub const SPA_ANSI_BOLD: &[u8; 5usize] = b"\x1B[1m\0";
pub const SPA_ANSI_ITALIC: &[u8; 5usize] = b"\x1B[3m\0";
pub const SPA_ANSI_UNDERLINE: &[u8; 5usize] = b"\x1B[4m\0";
pub const SPA_ANSI_BLACK: &[u8; 8usize] = b"\x1B[0;30m\0";
pub const SPA_ANSI_RED: &[u8; 8usize] = b"\x1B[0;31m\0";
pub const SPA_ANSI_GREEN: &[u8; 8usize] = b"\x1B[0;32m\0";
pub const SPA_ANSI_YELLOW: &[u8; 8usize] = b"\x1B[0;33m\0";
pub const SPA_ANSI_BLUE: &[u8; 8usize] = b"\x1B[0;34m\0";
pub const SPA_ANSI_MAGENTA: &[u8; 8usize] = b"\x1B[0;35m\0";
pub const SPA_ANSI_CYAN: &[u8; 8usize] = b"\x1B[0;36m\0";
pub const SPA_ANSI_WHITE: &[u8; 8usize] = b"\x1B[0;37m\0";
pub const SPA_ANSI_BRIGHT_BLACK: &[u8; 6usize] = b"\x1B[90m\0";
pub const SPA_ANSI_BRIGHT_RED: &[u8; 6usize] = b"\x1B[91m\0";
pub const SPA_ANSI_BRIGHT_GREEN: &[u8; 6usize] = b"\x1B[92m\0";
pub const SPA_ANSI_BRIGHT_YELLOW: &[u8; 6usize] = b"\x1B[93m\0";
pub const SPA_ANSI_BRIGHT_BLUE: &[u8; 6usize] = b"\x1B[94m\0";
pub const SPA_ANSI_BRIGHT_MAGENTA: &[u8; 6usize] = b"\x1B[95m\0";
pub const SPA_ANSI_BRIGHT_CYAN: &[u8; 6usize] = b"\x1B[96m\0";
pub const SPA_ANSI_BRIGHT_WHITE: &[u8; 6usize] = b"\x1B[97m\0";
pub const SPA_ANSI_BOLD_BLACK: &[u8; 8usize] = b"\x1B[1;30m\0";
pub const SPA_ANSI_BOLD_RED: &[u8; 8usize] = b"\x1B[1;31m\0";
pub const SPA_ANSI_BOLD_GREEN: &[u8; 8usize] = b"\x1B[1;32m\0";
pub const SPA_ANSI_BOLD_YELLOW: &[u8; 8usize] = b"\x1B[1;33m\0";
pub const SPA_ANSI_BOLD_BLUE: &[u8; 8usize] = b"\x1B[1;34m\0";
pub const SPA_ANSI_BOLD_MAGENTA: &[u8; 8usize] = b"\x1B[1;35m\0";
pub const SPA_ANSI_BOLD_CYAN: &[u8; 8usize] = b"\x1B[1;36m\0";
pub const SPA_ANSI_BOLD_WHITE: &[u8; 8usize] = b"\x1B[1;37m\0";
pub const SPA_ANSI_DARK_BLACK: &[u8; 8usize] = b"\x1B[2;30m\0";
pub const SPA_ANSI_DARK_RED: &[u8; 8usize] = b"\x1B[2;31m\0";
pub const SPA_ANSI_DARK_GREEN: &[u8; 8usize] = b"\x1B[2;32m\0";
pub const SPA_ANSI_DARK_YELLOW: &[u8; 8usize] = b"\x1B[2;33m\0";
pub const SPA_ANSI_DARK_BLUE: &[u8; 8usize] = b"\x1B[2;34m\0";
pub const SPA_ANSI_DARK_MAGENTA: &[u8; 8usize] = b"\x1B[2;35m\0";
pub const SPA_ANSI_DARK_CYAN: &[u8; 8usize] = b"\x1B[2;36m\0";
pub const SPA_ANSI_DARK_WHITE: &[u8; 8usize] = b"\x1B[2;37m\0";
pub const SPA_ANSI_BG_BLACK: &[u8; 8usize] = b"\x1B[0;40m\0";
pub const SPA_ANSI_BG_RED: &[u8; 8usize] = b"\x1B[0;41m\0";
pub const SPA_ANSI_BG_GREEN: &[u8; 8usize] = b"\x1B[0;42m\0";
pub const SPA_ANSI_BG_YELLOW: &[u8; 8usize] = b"\x1B[0;43m\0";
pub const SPA_ANSI_BG_BLUE: &[u8; 8usize] = b"\x1B[0;44m\0";
pub const SPA_ANSI_BG_MAGENTA: &[u8; 8usize] = b"\x1B[0;45m\0";
pub const SPA_ANSI_BG_CYAN: &[u8; 8usize] = b"\x1B[0;46m\0";
pub const SPA_ANSI_BG_WHITE: &[u8; 8usize] = b"\x1B[0;47m\0";
pub const SPA_ANSI_BG_BRIGHT_BLACK: &[u8; 7usize] = b"\x1B[100m\0";
pub const SPA_ANSI_BG_BRIGHT_RED: &[u8; 7usize] = b"\x1B[101m\0";
pub const SPA_ANSI_BG_BRIGHT_GREEN: &[u8; 7usize] = b"\x1B[102m\0";
pub const SPA_ANSI_BG_BRIGHT_YELLOW: &[u8; 7usize] = b"\x1B[103m\0";
pub const SPA_ANSI_BG_BRIGHT_BLUE: &[u8; 7usize] = b"\x1B[104m\0";
pub const SPA_ANSI_BG_BRIGHT_MAGENTA: &[u8; 7usize] = b"\x1B[105m\0";
pub const SPA_ANSI_BG_BRIGHT_CYAN: &[u8; 7usize] = b"\x1B[106m\0";
pub const SPA_ANSI_BG_BRIGHT_WHITE: &[u8; 7usize] = b"\x1B[107m\0";
pub const SPA_KEY_OBJECT_PATH: &[u8; 12usize] = b"object.path\0";
pub const SPA_KEY_MEDIA_CLASS: &[u8; 12usize] = b"media.class\0";
pub const SPA_KEY_MEDIA_ROLE: &[u8; 11usize] = b"media.role\0";
pub const SPA_KEY_API_UDEV: &[u8; 9usize] = b"api.udev\0";
pub const SPA_KEY_API_UDEV_MATCH: &[u8; 15usize] = b"api.udev.match\0";
pub const SPA_KEY_API_ALSA: &[u8; 9usize] = b"api.alsa\0";
pub const SPA_KEY_API_ALSA_PATH: &[u8; 14usize] = b"api.alsa.path\0";
pub const SPA_KEY_API_ALSA_CARD: &[u8; 14usize] = b"api.alsa.card\0";
pub const SPA_KEY_API_ALSA_USE_UCM: &[u8; 17usize] = b"api.alsa.use-ucm\0";
pub const SPA_KEY_API_ALSA_IGNORE_DB: &[u8; 19usize] = b"api.alsa.ignore-dB\0";
pub const SPA_KEY_API_ALSA_OPEN_UCM: &[u8; 18usize] = b"api.alsa.open.ucm\0";
pub const SPA_KEY_API_ALSA_DISABLE_LONGNAME: &[u8; 26usize] = b"api.alsa.disable-longname\0";
pub const SPA_KEY_API_ALSA_CARD_ID: &[u8; 17usize] = b"api.alsa.card.id\0";
pub const SPA_KEY_API_ALSA_CARD_COMPONENTS: &[u8; 25usize] = b"api.alsa.card.components\0";
pub const SPA_KEY_API_ALSA_CARD_DRIVER: &[u8; 21usize] = b"api.alsa.card.driver\0";
pub const SPA_KEY_API_ALSA_CARD_NAME: &[u8; 19usize] = b"api.alsa.card.name\0";
pub const SPA_KEY_API_ALSA_CARD_LONGNAME: &[u8; 23usize] = b"api.alsa.card.longname\0";
pub const SPA_KEY_API_ALSA_CARD_MIXERNAME: &[u8; 24usize] = b"api.alsa.card.mixername\0";
pub const SPA_KEY_API_ALSA_PCM_ID: &[u8; 16usize] = b"api.alsa.pcm.id\0";
pub const SPA_KEY_API_ALSA_PCM_CARD: &[u8; 18usize] = b"api.alsa.pcm.card\0";
pub const SPA_KEY_API_ALSA_PCM_NAME: &[u8; 18usize] = b"api.alsa.pcm.name\0";
pub const SPA_KEY_API_ALSA_PCM_SUBNAME: &[u8; 21usize] = b"api.alsa.pcm.subname\0";
pub const SPA_KEY_API_ALSA_PCM_STREAM: &[u8; 20usize] = b"api.alsa.pcm.stream\0";
pub const SPA_KEY_API_ALSA_PCM_CLASS: &[u8; 19usize] = b"api.alsa.pcm.class\0";
pub const SPA_KEY_API_ALSA_PCM_DEVICE: &[u8; 20usize] = b"api.alsa.pcm.device\0";
pub const SPA_KEY_API_ALSA_PCM_SUBDEVICE: &[u8; 23usize] = b"api.alsa.pcm.subdevice\0";
pub const SPA_KEY_API_ALSA_PCM_SUBCLASS: &[u8; 22usize] = b"api.alsa.pcm.subclass\0";
pub const SPA_KEY_API_ALSA_PCM_SYNC_ID: &[u8; 21usize] = b"api.alsa.pcm.sync-id\0";
pub const SPA_KEY_API_V4L2: &[u8; 9usize] = b"api.v4l2\0";
pub const SPA_KEY_API_V4L2_PATH: &[u8; 14usize] = b"api.v4l2.path\0";
pub const SPA_KEY_API_LIBCAMERA: &[u8; 14usize] = b"api.libcamera\0";
pub const SPA_KEY_API_LIBCAMERA_PATH: &[u8; 19usize] = b"api.libcamera.path\0";
pub const SPA_KEY_API_LIBCAMERA_LOCATION: &[u8; 23usize] = b"api.libcamera.location\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_DRIVER: &[u8; 25usize] = b"api.libcamera.cap.driver\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_CARD: &[u8; 23usize] = b"api.libcamera.cap.card\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_BUS_INFO: &[u8; 27usize] = b"api.libcamera.cap.bus_info\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_VERSION: &[u8; 26usize] = b"api.libcamera.cap.version\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_CAPABILITIES: &[u8; 31usize] =
    b"api.libcamera.cap.capabilities\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_DEVICE_CAPS: &[u8; 30usize] =
    b"api.libcamera.cap.device-caps\0";
pub const SPA_KEY_API_V4L2_CAP_DRIVER: &[u8; 20usize] = b"api.v4l2.cap.driver\0";
pub const SPA_KEY_API_V4L2_CAP_CARD: &[u8; 18usize] = b"api.v4l2.cap.card\0";
pub const SPA_KEY_API_V4L2_CAP_BUS_INFO: &[u8; 22usize] = b"api.v4l2.cap.bus_info\0";
pub const SPA_KEY_API_V4L2_CAP_VERSION: &[u8; 21usize] = b"api.v4l2.cap.version\0";
pub const SPA_KEY_API_V4L2_CAP_CAPABILITIES: &[u8; 26usize] = b"api.v4l2.cap.capabilities\0";
pub const SPA_KEY_API_V4L2_CAP_DEVICE_CAPS: &[u8; 25usize] = b"api.v4l2.cap.device-caps\0";
pub const SPA_KEY_API_BLUEZ5: &[u8; 11usize] = b"api.bluez5\0";
pub const SPA_KEY_API_BLUEZ5_PATH: &[u8; 16usize] = b"api.bluez5.path\0";
pub const SPA_KEY_API_BLUEZ5_DEVICE: &[u8; 18usize] = b"api.bluez5.device\0";
pub const SPA_KEY_API_BLUEZ5_CONNECTION: &[u8; 22usize] = b"api.bluez5.connection\0";
pub const SPA_KEY_API_BLUEZ5_TRANSPORT: &[u8; 21usize] = b"api.bluez5.transport\0";
pub const SPA_KEY_API_BLUEZ5_PROFILE: &[u8; 19usize] = b"api.bluez5.profile\0";
pub const SPA_KEY_API_BLUEZ5_ADDRESS: &[u8; 19usize] = b"api.bluez5.address\0";
pub const SPA_KEY_API_BLUEZ5_CODEC: &[u8; 17usize] = b"api.bluez5.codec\0";
pub const SPA_KEY_API_BLUEZ5_CLASS: &[u8; 17usize] = b"api.bluez5.class\0";
pub const SPA_KEY_API_BLUEZ5_ICON: &[u8; 16usize] = b"api.bluez5.icon\0";
pub const SPA_KEY_API_BLUEZ5_ROLE: &[u8; 16usize] = b"api.bluez5.role\0";
pub const SPA_KEY_API_JACK: &[u8; 9usize] = b"api.jack\0";
pub const SPA_KEY_API_JACK_SERVER: &[u8; 16usize] = b"api.jack.server\0";
pub const SPA_KEY_API_JACK_CLIENT: &[u8; 16usize] = b"api.jack.client\0";
pub const SPA_KEY_API_GLIB_MAINLOOP: &[u8; 18usize] = b"api.glib.mainloop\0";
pub const SPA_NAME_SUPPORT_CPU: &[u8; 12usize] = b"support.cpu\0";
pub const SPA_NAME_SUPPORT_DBUS: &[u8; 13usize] = b"support.dbus\0";
pub const SPA_NAME_SUPPORT_LOG: &[u8; 12usize] = b"support.log\0";
pub const SPA_NAME_SUPPORT_LOOP: &[u8; 13usize] = b"support.loop\0";
pub const SPA_NAME_SUPPORT_SYSTEM: &[u8; 15usize] = b"support.system\0";
pub const SPA_NAME_SUPPORT_NODE_DRIVER: &[u8; 20usize] = b"support.node.driver\0";
pub const SPA_NAME_CONTROL_MIXER: &[u8; 14usize] = b"control.mixer\0";
pub const SPA_NAME_AUDIO_MIXER: &[u8; 12usize] = b"audio.mixer\0";
pub const SPA_NAME_AUDIO_MIXER_DSP: &[u8; 16usize] = b"audio.mixer.dsp\0";
pub const SPA_NAME_AUDIO_PROCESS_FORMAT: &[u8; 21usize] = b"audio.process.format\0";
pub const SPA_NAME_AUDIO_PROCESS_CHANNELMIX: &[u8; 25usize] = b"audio.process.channelmix\0";
pub const SPA_NAME_AUDIO_PROCESS_RESAMPLE: &[u8; 23usize] = b"audio.process.resample\0";
pub const SPA_NAME_AUDIO_PROCESS_DEINTERLEAVE: &[u8; 27usize] = b"audio.process.deinterleave\0";
pub const SPA_NAME_AUDIO_PROCESS_INTERLEAVE: &[u8; 25usize] = b"audio.process.interleave\0";
pub const SPA_NAME_AUDIO_CONVERT: &[u8; 14usize] = b"audio.convert\0";
pub const SPA_NAME_AUDIO_ADAPT: &[u8; 12usize] = b"audio.adapt\0";
pub const SPA_NAME_AEC: &[u8; 10usize] = b"audio.aec\0";
pub const SPA_NAME_VIDEO_PROCESS_FORMAT: &[u8; 21usize] = b"video.process.format\0";
pub const SPA_NAME_VIDEO_PROCESS_SCALE: &[u8; 20usize] = b"video.process.scale\0";
pub const SPA_NAME_VIDEO_CONVERT: &[u8; 14usize] = b"video.convert\0";
pub const SPA_NAME_VIDEO_ADAPT: &[u8; 12usize] = b"video.adapt\0";
pub const SPA_NAME_API_ALSA_ENUM_UDEV: &[u8; 19usize] = b"api.alsa.enum.udev\0";
pub const SPA_NAME_API_ALSA_PCM_DEVICE: &[u8; 20usize] = b"api.alsa.pcm.device\0";
pub const SPA_NAME_API_ALSA_PCM_SOURCE: &[u8; 20usize] = b"api.alsa.pcm.source\0";
pub const SPA_NAME_API_ALSA_PCM_SINK: &[u8; 18usize] = b"api.alsa.pcm.sink\0";
pub const SPA_NAME_API_ALSA_SEQ_DEVICE: &[u8; 20usize] = b"api.alsa.seq.device\0";
pub const SPA_NAME_API_ALSA_SEQ_SOURCE: &[u8; 20usize] = b"api.alsa.seq.source\0";
pub const SPA_NAME_API_ALSA_SEQ_SINK: &[u8; 18usize] = b"api.alsa.seq.sink\0";
pub const SPA_NAME_API_ALSA_SEQ_BRIDGE: &[u8; 20usize] = b"api.alsa.seq.bridge\0";
pub const SPA_NAME_API_ALSA_ACP_DEVICE: &[u8; 20usize] = b"api.alsa.acp.device\0";
pub const SPA_NAME_API_ALSA_COMPRESS_OFFLOAD_SINK: &[u8; 31usize] =
    b"api.alsa.compress.offload.sink\0";
pub const SPA_NAME_API_BLUEZ5_ENUM_DBUS: &[u8; 21usize] = b"api.bluez5.enum.dbus\0";
pub const SPA_NAME_API_BLUEZ5_DEVICE: &[u8; 18usize] = b"api.bluez5.device\0";
pub const SPA_NAME_API_BLUEZ5_MEDIA_SINK: &[u8; 22usize] = b"api.bluez5.media.sink\0";
pub const SPA_NAME_API_BLUEZ5_MEDIA_SOURCE: &[u8; 24usize] = b"api.bluez5.media.source\0";
pub const SPA_NAME_API_BLUEZ5_A2DP_SINK: &[u8; 21usize] = b"api.bluez5.a2dp.sink\0";
pub const SPA_NAME_API_BLUEZ5_A2DP_SOURCE: &[u8; 23usize] = b"api.bluez5.a2dp.source\0";
pub const SPA_NAME_API_BLUEZ5_SCO_SINK: &[u8; 20usize] = b"api.bluez5.sco.sink\0";
pub const SPA_NAME_API_BLUEZ5_SCO_SOURCE: &[u8; 22usize] = b"api.bluez5.sco.source\0";
pub const SPA_NAME_API_BLUEZ5_MIDI_ENUM: &[u8; 21usize] = b"api.bluez5.midi.enum\0";
pub const SPA_NAME_API_BLUEZ5_MIDI_NODE: &[u8; 21usize] = b"api.bluez5.midi.node\0";
pub const SPA_NAME_API_CODEC_BLUEZ5_MEDIA: &[u8; 23usize] = b"api.codec.bluez5.media\0";
pub const SPA_NAME_API_V4L2_ENUM_UDEV: &[u8; 19usize] = b"api.v4l2.enum.udev\0";
pub const SPA_NAME_API_V4L2_DEVICE: &[u8; 16usize] = b"api.v4l2.device\0";
pub const SPA_NAME_API_V4L2_SOURCE: &[u8; 16usize] = b"api.v4l2.source\0";
pub const SPA_NAME_API_LIBCAMERA_ENUM_CLIENT: &[u8; 26usize] = b"api.libcamera.enum.client\0";
pub const SPA_NAME_API_LIBCAMERA_ENUM_MANAGER: &[u8; 27usize] = b"api.libcamera.enum.manager\0";
pub const SPA_NAME_API_LIBCAMERA_DEVICE: &[u8; 21usize] = b"api.libcamera.device\0";
pub const SPA_NAME_API_LIBCAMERA_SOURCE: &[u8; 21usize] = b"api.libcamera.source\0";
pub const SPA_NAME_API_JACK_DEVICE: &[u8; 16usize] = b"api.jack.device\0";
pub const SPA_NAME_API_JACK_SOURCE: &[u8; 16usize] = b"api.jack.source\0";
pub const SPA_NAME_API_JACK_SINK: &[u8; 14usize] = b"api.jack.sink\0";
pub const SPA_NAME_API_VULKAN_COMPUTE_SOURCE: &[u8; 26usize] = b"api.vulkan.compute.source\0";
pub const SPA_NAME_API_VULKAN_COMPUTE_FILTER: &[u8; 26usize] = b"api.vulkan.compute.filter\0";
pub const SPA_ASYNC_BIT: u32 = 1073741824;
pub const SPA_ASYNC_SEQ_MASK: u32 = 1073741823;
pub const SPA_ASYNC_MASK: i32 = -1073741824;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type va_list = __builtin_va_list;
pub const SPA_DIRECTION_INPUT: spa_direction = 0;
pub const SPA_DIRECTION_OUTPUT: spa_direction = 1;
pub type spa_direction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_rectangle {
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_spa_rectangle() {
    const UNINIT: ::std::mem::MaybeUninit<spa_rectangle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_rectangle>(),
        8usize,
        concat!("Size of: ", stringify!(spa_rectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_rectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_rectangle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_rectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_rectangle),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_point {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_spa_point() {
    const UNINIT: ::std::mem::MaybeUninit<spa_point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_point>(),
        8usize,
        concat!("Size of: ", stringify!(spa_point))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_point>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_point),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_region {
    pub position: spa_point,
    pub size: spa_rectangle,
}
#[test]
fn bindgen_test_layout_spa_region() {
    const UNINIT: ::std::mem::MaybeUninit<spa_region> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_region>(),
        16usize,
        concat!("Size of: ", stringify!(spa_region))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_region>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_region))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_region),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_region),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_fraction {
    pub num: u32,
    pub denom: u32,
}
#[test]
fn bindgen_test_layout_spa_fraction() {
    const UNINIT: ::std::mem::MaybeUninit<spa_fraction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_fraction>(),
        8usize,
        concat!("Size of: ", stringify!(spa_fraction))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_fraction>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_fraction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_fraction),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).denom) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_fraction),
            "::",
            stringify!(denom)
        )
    );
}
pub const SPA_TYPE_START: _bindgen_ty_10 = 0;
pub const SPA_TYPE_None: _bindgen_ty_10 = 1;
pub const SPA_TYPE_Bool: _bindgen_ty_10 = 2;
pub const SPA_TYPE_Id: _bindgen_ty_10 = 3;
pub const SPA_TYPE_Int: _bindgen_ty_10 = 4;
pub const SPA_TYPE_Long: _bindgen_ty_10 = 5;
pub const SPA_TYPE_Float: _bindgen_ty_10 = 6;
pub const SPA_TYPE_Double: _bindgen_ty_10 = 7;
pub const SPA_TYPE_String: _bindgen_ty_10 = 8;
pub const SPA_TYPE_Bytes: _bindgen_ty_10 = 9;
pub const SPA_TYPE_Rectangle: _bindgen_ty_10 = 10;
pub const SPA_TYPE_Fraction: _bindgen_ty_10 = 11;
pub const SPA_TYPE_Bitmap: _bindgen_ty_10 = 12;
pub const SPA_TYPE_Array: _bindgen_ty_10 = 13;
pub const SPA_TYPE_Struct: _bindgen_ty_10 = 14;
pub const SPA_TYPE_Object: _bindgen_ty_10 = 15;
pub const SPA_TYPE_Sequence: _bindgen_ty_10 = 16;
pub const SPA_TYPE_Pointer: _bindgen_ty_10 = 17;
pub const SPA_TYPE_Fd: _bindgen_ty_10 = 18;
pub const SPA_TYPE_Choice: _bindgen_ty_10 = 19;
pub const SPA_TYPE_Pod: _bindgen_ty_10 = 20;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_LAST: _bindgen_ty_10 = 21;
pub const SPA_TYPE_POINTER_START: _bindgen_ty_10 = 65536;
pub const SPA_TYPE_POINTER_Buffer: _bindgen_ty_10 = 65537;
pub const SPA_TYPE_POINTER_Meta: _bindgen_ty_10 = 65538;
pub const SPA_TYPE_POINTER_Dict: _bindgen_ty_10 = 65539;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_POINTER_LAST: _bindgen_ty_10 = 65540;
pub const SPA_TYPE_EVENT_START: _bindgen_ty_10 = 131072;
pub const SPA_TYPE_EVENT_Device: _bindgen_ty_10 = 131073;
pub const SPA_TYPE_EVENT_Node: _bindgen_ty_10 = 131074;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_EVENT_LAST: _bindgen_ty_10 = 131075;
pub const SPA_TYPE_COMMAND_START: _bindgen_ty_10 = 196608;
pub const SPA_TYPE_COMMAND_Device: _bindgen_ty_10 = 196609;
pub const SPA_TYPE_COMMAND_Node: _bindgen_ty_10 = 196610;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_COMMAND_LAST: _bindgen_ty_10 = 196611;
pub const SPA_TYPE_OBJECT_START: _bindgen_ty_10 = 262144;
pub const SPA_TYPE_OBJECT_PropInfo: _bindgen_ty_10 = 262145;
pub const SPA_TYPE_OBJECT_Props: _bindgen_ty_10 = 262146;
pub const SPA_TYPE_OBJECT_Format: _bindgen_ty_10 = 262147;
pub const SPA_TYPE_OBJECT_ParamBuffers: _bindgen_ty_10 = 262148;
pub const SPA_TYPE_OBJECT_ParamMeta: _bindgen_ty_10 = 262149;
pub const SPA_TYPE_OBJECT_ParamIO: _bindgen_ty_10 = 262150;
pub const SPA_TYPE_OBJECT_ParamProfile: _bindgen_ty_10 = 262151;
pub const SPA_TYPE_OBJECT_ParamPortConfig: _bindgen_ty_10 = 262152;
pub const SPA_TYPE_OBJECT_ParamRoute: _bindgen_ty_10 = 262153;
pub const SPA_TYPE_OBJECT_Profiler: _bindgen_ty_10 = 262154;
pub const SPA_TYPE_OBJECT_ParamLatency: _bindgen_ty_10 = 262155;
pub const SPA_TYPE_OBJECT_ParamProcessLatency: _bindgen_ty_10 = 262156;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_OBJECT_LAST: _bindgen_ty_10 = 262157;
pub const SPA_TYPE_VENDOR_PipeWire: _bindgen_ty_10 = 33554432;
pub const SPA_TYPE_VENDOR_Other: _bindgen_ty_10 = 2130706432;
#[doc = " \\addtogroup spa_types\n \\{"]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_type_info {
    pub type_: u32,
    pub parent: u32,
    pub name: *const ::std::os::raw::c_char,
    pub values: *const spa_type_info,
}
#[test]
fn bindgen_test_layout_spa_type_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_type_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_type_info>(),
        24usize,
        concat!("Size of: ", stringify!(spa_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_type_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_type_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_type_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_type_info),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_type_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_type_info),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod {
    pub size: u32,
    pub type_: u32,
}
#[test]
fn bindgen_test_layout_spa_pod() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod>(),
        8usize,
        concat!("Size of: ", stringify!(spa_pod))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_bool {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[test]
fn bindgen_test_layout_spa_pod_bool() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_bool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_bool>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_bool))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_bool>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_bool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_bool),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_bool),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_bool),
            "::",
            stringify!(_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_id {
    pub pod: spa_pod,
    pub value: u32,
    pub _padding: i32,
}
#[test]
fn bindgen_test_layout_spa_pod_id() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_id>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_id))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_id>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_id),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_id),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_id),
            "::",
            stringify!(_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_int {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[test]
fn bindgen_test_layout_spa_pod_int() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_int> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_int>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_int))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_int>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_int))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_int),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_int),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_int),
            "::",
            stringify!(_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_long {
    pub pod: spa_pod,
    pub value: i64,
}
#[test]
fn bindgen_test_layout_spa_pod_long() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_long> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_long>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_long))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_long>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_long))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_long),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_long),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_pod_float {
    pub pod: spa_pod,
    pub value: f32,
    pub _padding: i32,
}
#[test]
fn bindgen_test_layout_spa_pod_float() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_float> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_float>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_float))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_float>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_float))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_float),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_float),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_float),
            "::",
            stringify!(_padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_pod_double {
    pub pod: spa_pod,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_spa_pod_double() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_double> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_double>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_double))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_double>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_double))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_double),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_double),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_string {
    pub pod: spa_pod,
}
#[test]
fn bindgen_test_layout_spa_pod_string() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_string> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_string>(),
        8usize,
        concat!("Size of: ", stringify!(spa_pod_string))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_string>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_string))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_string),
            "::",
            stringify!(pod)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_bytes {
    pub pod: spa_pod,
}
#[test]
fn bindgen_test_layout_spa_pod_bytes() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_bytes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_bytes>(),
        8usize,
        concat!("Size of: ", stringify!(spa_pod_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_bytes>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_bytes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_bytes),
            "::",
            stringify!(pod)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_rectangle {
    pub pod: spa_pod,
    pub value: spa_rectangle,
}
#[test]
fn bindgen_test_layout_spa_pod_rectangle() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_rectangle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_rectangle>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_rectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_rectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_rectangle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_rectangle),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_rectangle),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_fraction {
    pub pod: spa_pod,
    pub value: spa_fraction,
}
#[test]
fn bindgen_test_layout_spa_pod_fraction() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_fraction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_fraction>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_fraction))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_fraction>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_fraction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_fraction),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_fraction),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_bitmap {
    pub pod: spa_pod,
}
#[test]
fn bindgen_test_layout_spa_pod_bitmap() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_bitmap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_bitmap>(),
        8usize,
        concat!("Size of: ", stringify!(spa_pod_bitmap))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_bitmap>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_bitmap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_bitmap),
            "::",
            stringify!(pod)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_array_body {
    pub child: spa_pod,
}
#[test]
fn bindgen_test_layout_spa_pod_array_body() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_array_body> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_array_body>(),
        8usize,
        concat!("Size of: ", stringify!(spa_pod_array_body))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_array_body>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_array_body))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_array_body),
            "::",
            stringify!(child)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_array {
    pub pod: spa_pod,
    pub body: spa_pod_array_body,
}
#[test]
fn bindgen_test_layout_spa_pod_array() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_array> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_array>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_array))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_array>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_array))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_array),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_array),
            "::",
            stringify!(body)
        )
    );
}
#[doc = "< no choice, first value is current"]
pub const SPA_CHOICE_None: spa_choice_type = 0;
#[doc = "< range: default, min, max"]
pub const SPA_CHOICE_Range: spa_choice_type = 1;
#[doc = "< range with step: default, min, max, step"]
pub const SPA_CHOICE_Step: spa_choice_type = 2;
#[doc = "< list: default, alternative,..."]
pub const SPA_CHOICE_Enum: spa_choice_type = 3;
#[doc = "< flags: default, possible flags,..."]
pub const SPA_CHOICE_Flags: spa_choice_type = 4;
pub type spa_choice_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_choice_body {
    #[doc = "< type of choice, one of enum spa_choice_type"]
    pub type_: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    pub child: spa_pod,
}
#[test]
fn bindgen_test_layout_spa_pod_choice_body() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_choice_body> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_choice_body>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_choice_body))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_choice_body>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_choice_body))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_choice_body),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_choice_body),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_choice_body),
            "::",
            stringify!(child)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_choice {
    pub pod: spa_pod,
    pub body: spa_pod_choice_body,
}
#[test]
fn bindgen_test_layout_spa_pod_choice() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_choice> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_choice>(),
        24usize,
        concat!("Size of: ", stringify!(spa_pod_choice))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_choice>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_choice))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_choice),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_choice),
            "::",
            stringify!(body)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_struct {
    pub pod: spa_pod,
}
#[test]
fn bindgen_test_layout_spa_pod_struct() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_struct>(),
        8usize,
        concat!("Size of: ", stringify!(spa_pod_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_struct),
            "::",
            stringify!(pod)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_object_body {
    #[doc = "< one of enum spa_type"]
    pub type_: u32,
    #[doc = "< id of the object, depends on the object type"]
    pub id: u32,
}
#[test]
fn bindgen_test_layout_spa_pod_object_body() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_object_body> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_object_body>(),
        8usize,
        concat!("Size of: ", stringify!(spa_pod_object_body))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_object_body>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_object_body))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_object_body),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_object_body),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_object {
    pub pod: spa_pod,
    pub body: spa_pod_object_body,
}
#[test]
fn bindgen_test_layout_spa_pod_object() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_object> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_object>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_object))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_object>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_object))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_object),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_object),
            "::",
            stringify!(body)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_pointer_body {
    #[doc = "< pointer id, one of enum spa_type"]
    pub type_: u32,
    pub _padding: u32,
    pub value: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_pod_pointer_body() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_pointer_body> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_pointer_body>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_pointer_body))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_pointer_body>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_pointer_body))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_pointer_body),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._padding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_pointer_body),
            "::",
            stringify!(_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_pointer_body),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_pointer {
    pub pod: spa_pod,
    pub body: spa_pod_pointer_body,
}
#[test]
fn bindgen_test_layout_spa_pod_pointer() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_pointer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_pointer>(),
        24usize,
        concat!("Size of: ", stringify!(spa_pod_pointer))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_pointer>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_pointer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_pointer),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_pointer),
            "::",
            stringify!(body)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_fd {
    pub pod: spa_pod,
    pub value: i64,
}
#[test]
fn bindgen_test_layout_spa_pod_fd() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_fd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_fd>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_fd))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_fd>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_fd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_fd),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_fd),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_prop {
    #[doc = "< key of property, list of valid keys depends on the\n  object type"]
    pub key: u32,
    #[doc = "< flags for property"]
    pub flags: u32,
    pub value: spa_pod,
}
#[test]
fn bindgen_test_layout_spa_pod_prop() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_prop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_prop>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_prop))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_prop>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_prop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_prop),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_prop),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_prop),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_control {
    #[doc = "< media offset"]
    pub offset: u32,
    #[doc = "< type of control, enum spa_control_type"]
    pub type_: u32,
    #[doc = "< control value, depends on type"]
    pub value: spa_pod,
}
#[test]
fn bindgen_test_layout_spa_pod_control() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_control> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_control>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_control))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_control>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_control),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_control),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_control),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_sequence_body {
    pub unit: u32,
    pub pad: u32,
}
#[test]
fn bindgen_test_layout_spa_pod_sequence_body() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_sequence_body> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_sequence_body>(),
        8usize,
        concat!("Size of: ", stringify!(spa_pod_sequence_body))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_sequence_body>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_sequence_body))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_sequence_body),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_sequence_body),
            "::",
            stringify!(pad)
        )
    );
}
#[doc = " a sequence of timed controls"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_sequence {
    pub pod: spa_pod,
    pub body: spa_pod_sequence_body,
}
#[test]
fn bindgen_test_layout_spa_pod_sequence() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_sequence> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_sequence>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_sequence>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_pod_sequence))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_sequence),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_sequence),
            "::",
            stringify!(body)
        )
    );
}
pub const SPA_META_Invalid: spa_meta_type = 0;
#[doc = "< struct spa_meta_header"]
pub const SPA_META_Header: spa_meta_type = 1;
#[doc = "< struct spa_meta_region with cropping data"]
pub const SPA_META_VideoCrop: spa_meta_type = 2;
#[doc = "< array of struct spa_meta_region with damage, where an invalid entry or end-of-array marks the end."]
pub const SPA_META_VideoDamage: spa_meta_type = 3;
#[doc = "< struct spa_meta_bitmap"]
pub const SPA_META_Bitmap: spa_meta_type = 4;
#[doc = "< struct spa_meta_cursor"]
pub const SPA_META_Cursor: spa_meta_type = 5;
#[doc = "< metadata contains a spa_meta_control\n  associated with the data"]
pub const SPA_META_Control: spa_meta_type = 6;
#[doc = "< don't write to buffer when count > 0"]
pub const SPA_META_Busy: spa_meta_type = 7;
#[doc = "< struct spa_meta_transform"]
pub const SPA_META_VideoTransform: spa_meta_type = 8;
#[doc = "< not part of ABI/API"]
pub const _SPA_META_LAST: spa_meta_type = 9;
#[doc = " \\addtogroup spa_buffer\n \\{"]
pub type spa_meta_type = ::std::os::raw::c_uint;
#[doc = " A metadata element.\n\n This structure is available on the buffer structure and contains\n the type of the metadata and a pointer/size to the actual metadata\n itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta {
    #[doc = "< metadata type, one of enum spa_meta_type"]
    pub type_: u32,
    #[doc = "< size of metadata"]
    pub size: u32,
    #[doc = "< pointer to metadata"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_meta() {
    const UNINIT: ::std::mem::MaybeUninit<spa_meta> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_meta>(),
        16usize,
        concat!("Size of: ", stringify!(spa_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_meta>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_meta))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Describes essential buffer header metadata such as flags and\n timestamps."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_header {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in current cycle"]
    pub offset: u32,
    #[doc = "< presentation timestamp in nanoseconds"]
    pub pts: i64,
    #[doc = "< decoding timestamp as a difference with pts"]
    pub dts_offset: i64,
    #[doc = "< sequence number, increments with a\n  media specific frequency"]
    pub seq: u64,
}
#[test]
fn bindgen_test_layout_spa_meta_header() {
    const UNINIT: ::std::mem::MaybeUninit<spa_meta_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_meta_header>(),
        32usize,
        concat!("Size of: ", stringify!(spa_meta_header))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_meta_header>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_meta_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_header),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_header),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_header),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dts_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_header),
            "::",
            stringify!(dts_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_header),
            "::",
            stringify!(seq)
        )
    );
}
#[doc = " metadata structure for Region or an array of these for RegionArray"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_region {
    pub region: spa_region,
}
#[test]
fn bindgen_test_layout_spa_meta_region() {
    const UNINIT: ::std::mem::MaybeUninit<spa_meta_region> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_meta_region>(),
        16usize,
        concat!("Size of: ", stringify!(spa_meta_region))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_meta_region>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_meta_region))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).region) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_region),
            "::",
            stringify!(region)
        )
    );
}
#[doc = " Bitmap information\n\n This metadata contains a bitmap image in the given format and size.\n It is typically used for cursor images or other small images that are\n better transferred inline."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_bitmap {
    #[doc = "< bitmap video format, one of enum spa_video_format. 0 is\n  and invalid format and should be handled as if there is\n  no new bitmap information."]
    pub format: u32,
    #[doc = "< width and height of bitmap"]
    pub size: spa_rectangle,
    #[doc = "< stride of bitmap data"]
    pub stride: i32,
    #[doc = "< offset of bitmap data in this structure. An offset of\n  0 means no image data (invisible), an offset >=\n  sizeof(struct spa_meta_bitmap) contains valid bitmap\n  info."]
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_spa_meta_bitmap() {
    const UNINIT: ::std::mem::MaybeUninit<spa_meta_bitmap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_meta_bitmap>(),
        20usize,
        concat!("Size of: ", stringify!(spa_meta_bitmap))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_meta_bitmap>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_meta_bitmap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_bitmap),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_bitmap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_bitmap),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_bitmap),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = " Cursor information\n\n Metadata to describe the position and appearance of a pointing device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_cursor {
    #[doc = "< cursor id. an id of 0 is an invalid id and means that\n  there is no new cursor data"]
    pub id: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< position on screen"]
    pub position: spa_point,
    #[doc = "< offsets for hotspot in bitmap, this field has no meaning\n  when there is no valid bitmap (see below)"]
    pub hotspot: spa_point,
    #[doc = "< offset of bitmap meta in this structure. When the offset\n  is 0, there is no new bitmap information. When the offset is\n  >= sizeof(struct spa_meta_cursor) there is a\n  struct spa_meta_bitmap at the offset."]
    pub bitmap_offset: u32,
}
#[test]
fn bindgen_test_layout_spa_meta_cursor() {
    const UNINIT: ::std::mem::MaybeUninit<spa_meta_cursor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_meta_cursor>(),
        28usize,
        concat!("Size of: ", stringify!(spa_meta_cursor))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_meta_cursor>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_meta_cursor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_cursor),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_cursor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_cursor),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hotspot) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_cursor),
            "::",
            stringify!(hotspot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmap_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_cursor),
            "::",
            stringify!(bitmap_offset)
        )
    );
}
#[doc = " a timed set of events associated with the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_control {
    pub sequence: spa_pod_sequence,
}
#[test]
fn bindgen_test_layout_spa_meta_control() {
    const UNINIT: ::std::mem::MaybeUninit<spa_meta_control> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_meta_control>(),
        16usize,
        concat!("Size of: ", stringify!(spa_meta_control))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_meta_control>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_meta_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_control),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " a busy counter for the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_busy {
    pub flags: u32,
    #[doc = "< number of users busy with the buffer"]
    pub count: u32,
}
#[test]
fn bindgen_test_layout_spa_meta_busy() {
    const UNINIT: ::std::mem::MaybeUninit<spa_meta_busy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_meta_busy>(),
        8usize,
        concat!("Size of: ", stringify!(spa_meta_busy))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_meta_busy>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_meta_busy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_busy),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_busy),
            "::",
            stringify!(count)
        )
    );
}
#[doc = "< no transform"]
pub const SPA_META_TRANSFORMATION_None: spa_meta_videotransform_value = 0;
#[doc = "< 90 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_90: spa_meta_videotransform_value = 1;
#[doc = "< 180 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_180: spa_meta_videotransform_value = 2;
#[doc = "< 270 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_270: spa_meta_videotransform_value = 3;
#[doc = "< 180 degree flipped around the vertical axis. Equivalent\n to a reflexion through the vertical line splitting the\n bufffer in two equal sized parts"]
pub const SPA_META_TRANSFORMATION_Flipped: spa_meta_videotransform_value = 4;
#[doc = "< flip then rotate around 90 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_Flipped90: spa_meta_videotransform_value = 5;
#[doc = "< flip then rotate around 180 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_Flipped180: spa_meta_videotransform_value = 6;
#[doc = "< flip then rotate around 270 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_Flipped270: spa_meta_videotransform_value = 7;
pub type spa_meta_videotransform_value = ::std::os::raw::c_uint;
#[doc = " a transformation of the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_videotransform {
    #[doc = "< orientation transformation that was applied to the buffer,\n  one of enum spa_meta_videotransform_value"]
    pub transform: u32,
}
#[test]
fn bindgen_test_layout_spa_meta_videotransform() {
    const UNINIT: ::std::mem::MaybeUninit<spa_meta_videotransform> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_meta_videotransform>(),
        4usize,
        concat!("Size of: ", stringify!(spa_meta_videotransform))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_meta_videotransform>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_meta_videotransform))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_meta_videotransform),
            "::",
            stringify!(transform)
        )
    );
}
pub const SPA_DATA_Invalid: spa_data_type = 0;
#[doc = "< pointer to memory, the data field in\n  struct spa_data is set."]
pub const SPA_DATA_MemPtr: spa_data_type = 1;
#[doc = "< generic fd, mmap to get to memory"]
pub const SPA_DATA_MemFd: spa_data_type = 2;
#[doc = "< fd to dmabuf memory"]
pub const SPA_DATA_DmaBuf: spa_data_type = 3;
#[doc = "< memory is identified with an id"]
pub const SPA_DATA_MemId: spa_data_type = 4;
#[doc = "< not part of ABI"]
pub const _SPA_DATA_LAST: spa_data_type = 5;
#[doc = " \\addtogroup spa_buffer\n \\{"]
pub type spa_data_type = ::std::os::raw::c_uint;
#[doc = " Chunk of memory, can change for each buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_chunk {
    #[doc = "< offset of valid data. Should be taken\n  modulo the data maxsize to get the offset\n  in the data memory."]
    pub offset: u32,
    #[doc = "< size of valid data. Should be clamped to\n  maxsize."]
    pub size: u32,
    #[doc = "< stride of valid data"]
    pub stride: i32,
    #[doc = "< chunk flags"]
    pub flags: i32,
}
#[test]
fn bindgen_test_layout_spa_chunk() {
    const UNINIT: ::std::mem::MaybeUninit<spa_chunk> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_chunk>(),
        16usize,
        concat!("Size of: ", stringify!(spa_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_chunk>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_chunk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_chunk),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_chunk),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_chunk),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_chunk),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Data for a buffer this stays constant for a buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_data {
    #[doc = "< memory type, one of enum spa_data_type, when\n  allocating memory, the type contains a bitmask\n  of allowed types. SPA_ID_INVALID is a special\n  value for the allocator to indicate that the\n  other side did not explicitly specify any\n  supported data types. It should probably use\n  a memory type that does not require special\n  handling in addition to simple mmap/munmap."]
    pub type_: u32,
    #[doc = "< data flags"]
    pub flags: u32,
    #[doc = "< optional fd for data"]
    pub fd: i64,
    #[doc = "< offset to map fd at"]
    pub mapoffset: u32,
    #[doc = "< max size of data"]
    pub maxsize: u32,
    #[doc = "< optional data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< valid chunk of memory"]
    pub chunk: *mut spa_chunk,
}
#[test]
fn bindgen_test_layout_spa_data() {
    const UNINIT: ::std::mem::MaybeUninit<spa_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_data>(),
        40usize,
        concat!("Size of: ", stringify!(spa_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_data>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_data),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mapoffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_data),
            "::",
            stringify!(mapoffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxsize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_data),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunk) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_data),
            "::",
            stringify!(chunk)
        )
    );
}
#[doc = " A Buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_buffer {
    #[doc = "< number of metadata"]
    pub n_metas: u32,
    #[doc = "< number of data members"]
    pub n_datas: u32,
    #[doc = "< array of metadata"]
    pub metas: *mut spa_meta,
    #[doc = "< array of data members"]
    pub datas: *mut spa_data,
}
#[test]
fn bindgen_test_layout_spa_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<spa_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(spa_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_metas) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer),
            "::",
            stringify!(n_metas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_datas) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer),
            "::",
            stringify!(n_datas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metas) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer),
            "::",
            stringify!(metas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datas) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer),
            "::",
            stringify!(datas)
        )
    );
}
#[doc = " information about the buffer layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_buffer_alloc_info {
    pub flags: u32,
    #[doc = "< max of all alignments"]
    pub max_align: u32,
    pub n_metas: u32,
    pub n_datas: u32,
    pub metas: *mut spa_meta,
    pub datas: *mut spa_data,
    pub data_aligns: *mut u32,
    #[doc = "< size of the struct spa_buffer and inlined meta/chunk/data"]
    pub skel_size: usize,
    #[doc = "< size of the meta if not inlined"]
    pub meta_size: usize,
    #[doc = "< size of the chunk if not inlined"]
    pub chunk_size: usize,
    #[doc = "< size of the data if not inlined"]
    pub data_size: usize,
    #[doc = "< size of the total memory if not inlined"]
    pub mem_size: usize,
}
#[test]
fn bindgen_test_layout_spa_buffer_alloc_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_buffer_alloc_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_buffer_alloc_info>(),
        80usize,
        concat!("Size of: ", stringify!(spa_buffer_alloc_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_buffer_alloc_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_buffer_alloc_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_align) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(max_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_metas) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(n_metas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_datas) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(n_datas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metas) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(metas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datas) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(datas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_aligns) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(data_aligns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skel_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(skel_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meta_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(meta_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunk_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(chunk_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem_size) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_buffer_alloc_info),
            "::",
            stringify!(mem_size)
        )
    );
}
pub const SPA_CONTROL_Invalid: spa_control_type = 0;
#[doc = "< data contains a SPA_TYPE_OBJECT_Props"]
pub const SPA_CONTROL_Properties: spa_control_type = 1;
#[doc = "< data contains a spa_pod_bytes with raw midi data"]
pub const SPA_CONTROL_Midi: spa_control_type = 2;
#[doc = "< data contains a spa_pod_bytes with an OSC packet"]
pub const SPA_CONTROL_OSC: spa_control_type = 3;
#[doc = "< not part of ABI"]
pub const _SPA_CONTROL_LAST: spa_control_type = 4;
#[doc = " Different Control types"]
pub type spa_control_type = ::std::os::raw::c_uint;
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_event_body {
    pub body: spa_pod_object_body,
}
#[test]
fn bindgen_test_layout_spa_event_body() {
    const UNINIT: ::std::mem::MaybeUninit<spa_event_body> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_event_body>(),
        8usize,
        concat!("Size of: ", stringify!(spa_event_body))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_event_body>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_event_body))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_event_body),
            "::",
            stringify!(body)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_event {
    pub pod: spa_pod,
    pub body: spa_event_body,
}
#[test]
fn bindgen_test_layout_spa_event() {
    const UNINIT: ::std::mem::MaybeUninit<spa_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_event>(),
        16usize,
        concat!("Size of: ", stringify!(spa_event))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_event>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_event),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_event),
            "::",
            stringify!(body)
        )
    );
}
pub const SPA_DEVICE_EVENT_ObjectConfig: spa_device_event = 0;
#[doc = " \\addtogroup spa_device\n \\{"]
pub type spa_device_event = ::std::os::raw::c_uint;
pub const SPA_EVENT_DEVICE_START: spa_event_device = 0;
pub const SPA_EVENT_DEVICE_Object: spa_event_device = 1;
pub const SPA_EVENT_DEVICE_Props: spa_event_device = 2;
pub type spa_event_device = ::std::os::raw::c_uint;
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_command_body {
    pub body: spa_pod_object_body,
}
#[test]
fn bindgen_test_layout_spa_command_body() {
    const UNINIT: ::std::mem::MaybeUninit<spa_command_body> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_command_body>(),
        8usize,
        concat!("Size of: ", stringify!(spa_command_body))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_command_body>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_command_body))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_command_body),
            "::",
            stringify!(body)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_command {
    pub pod: spa_pod,
    pub body: spa_command_body,
}
#[test]
fn bindgen_test_layout_spa_command() {
    const UNINIT: ::std::mem::MaybeUninit<spa_command> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_command>(),
        16usize,
        concat!("Size of: ", stringify!(spa_command))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_command>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_command))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_command),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_command),
            "::",
            stringify!(body)
        )
    );
}
#[doc = "< suspend a node, this removes all configured\n formats and closes any devices"]
pub const SPA_NODE_COMMAND_Suspend: spa_node_command = 0;
#[doc = "< pause a node. this makes it stop emitting\n  scheduling events"]
pub const SPA_NODE_COMMAND_Pause: spa_node_command = 1;
#[doc = "< start a node, this makes it start emitting\n  scheduling events"]
pub const SPA_NODE_COMMAND_Start: spa_node_command = 2;
pub const SPA_NODE_COMMAND_Enable: spa_node_command = 3;
pub const SPA_NODE_COMMAND_Disable: spa_node_command = 4;
pub const SPA_NODE_COMMAND_Flush: spa_node_command = 5;
pub const SPA_NODE_COMMAND_Drain: spa_node_command = 6;
pub const SPA_NODE_COMMAND_Marker: spa_node_command = 7;
#[doc = "< begin a set of parameter enumerations or\n  configuration that require the device to\n  remain opened, like query formats and then\n  set a format"]
pub const SPA_NODE_COMMAND_ParamBegin: spa_node_command = 8;
#[doc = "< end a transaction"]
pub const SPA_NODE_COMMAND_ParamEnd: spa_node_command = 9;
#[doc = "< Sent to a driver when some other node emitted\n  the RequestProcess event."]
pub const SPA_NODE_COMMAND_RequestProcess: spa_node_command = 10;
pub type spa_node_command = ::std::os::raw::c_uint;
pub const SPA_NODE_EVENT_Error: spa_node_event = 0;
pub const SPA_NODE_EVENT_Buffering: spa_node_event = 1;
pub const SPA_NODE_EVENT_RequestRefresh: spa_node_event = 2;
pub const SPA_NODE_EVENT_RequestProcess: spa_node_event = 3;
pub type spa_node_event = ::std::os::raw::c_uint;
pub const SPA_EVENT_NODE_START: spa_event_node = 0;
pub type spa_event_node = ::std::os::raw::c_uint;
pub const SPA_IO_Invalid: spa_io_type = 0;
#[doc = "< area to exchange buffers, struct spa_io_buffers"]
pub const SPA_IO_Buffers: spa_io_type = 1;
#[doc = "< expected byte range, struct spa_io_range"]
pub const SPA_IO_Range: spa_io_type = 2;
#[doc = "< area to update clock information, struct spa_io_clock"]
pub const SPA_IO_Clock: spa_io_type = 3;
#[doc = "< latency reporting, struct spa_io_latency"]
pub const SPA_IO_Latency: spa_io_type = 4;
#[doc = "< area for control messages, struct spa_io_sequence"]
pub const SPA_IO_Control: spa_io_type = 5;
#[doc = "< area for notify messages, struct spa_io_sequence"]
pub const SPA_IO_Notify: spa_io_type = 6;
#[doc = "< position information in the graph, struct spa_io_position"]
pub const SPA_IO_Position: spa_io_type = 7;
#[doc = "< rate matching between nodes, struct spa_io_rate_match"]
pub const SPA_IO_RateMatch: spa_io_type = 8;
#[doc = "< memory pointer, struct spa_io_memory"]
pub const SPA_IO_Memory: spa_io_type = 9;
#[doc = " Different IO area types"]
pub type spa_io_type = ::std::os::raw::c_uint;
#[doc = " IO area to exchange buffers.\n\n A set of buffers should first be configured on the node/port.\n Further references to those buffers will be made by using the\n id of the buffer.\n\n If status is SPA_STATUS_OK, the host should ignore\n the io area.\n\n If status is SPA_STATUS_NEED_DATA, the host should:\n 1) recycle the buffer in buffer_id, if possible\n 2) prepare a new buffer and place the id in buffer_id.\n\n If status is SPA_STATUS_HAVE_DATA, the host should consume\n the buffer in buffer_id and set the state to\n SPA_STATUS_NEED_DATA when new data is requested.\n\n If status is SPA_STATUS_STOPPED, some error occurred on the\n port.\n\n If status is SPA_STATUS_DRAINED, data from the io area was\n used to drain.\n\n Status can also be a negative errno value to indicate errors.\n such as:\n -EINVAL: buffer_id is invalid\n -EPIPE: no more buffers available"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_buffers {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< a buffer id"]
    pub buffer_id: u32,
}
#[test]
fn bindgen_test_layout_spa_io_buffers() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_buffers> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_buffers>(),
        8usize,
        concat!("Size of: ", stringify!(spa_io_buffers))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_buffers>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_io_buffers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_buffers),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_buffers),
            "::",
            stringify!(buffer_id)
        )
    );
}
#[doc = " IO area to exchange a memory region"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_memory {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< the size of \\a data"]
    pub size: u32,
    #[doc = "< a memory pointer"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_io_memory() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_memory> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_memory>(),
        16usize,
        concat!("Size of: ", stringify!(spa_io_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_memory>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_io_memory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_memory),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_memory),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_memory),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " A range, suitable for input ports that can suggest a range to output ports"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_range {
    #[doc = "< offset in range"]
    pub offset: u64,
    #[doc = "< minimum size of data"]
    pub min_size: u32,
    #[doc = "< maximum size of data"]
    pub max_size: u32,
}
#[test]
fn bindgen_test_layout_spa_io_range() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_range>(),
        16usize,
        concat!("Size of: ", stringify!(spa_io_range))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_range>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_io_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_range),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_range),
            "::",
            stringify!(min_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_range),
            "::",
            stringify!(max_size)
        )
    );
}
#[doc = " Absolute time reporting.\n\n Nodes that can report clocking information will receive this io block.\n The application sets the id. This is usually set as part of the\n position information but can also be set separately.\n\n The clock counts the elapsed time according to the clock provider\n since the provider was last started."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_clock {
    #[doc = "< clock flags"]
    pub flags: u32,
    #[doc = "< unique clock id, set by application"]
    pub id: u32,
    #[doc = "< clock name prefixed with API, set by node. The clock name\n  is unique per clock and can be used to check if nodes\n  share the same clock."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< time in nanoseconds against monotonic clock"]
    pub nsec: u64,
    #[doc = "< rate for position/duration/delay"]
    pub rate: spa_fraction,
    #[doc = "< current position"]
    pub position: u64,
    #[doc = "< duration of current cycle"]
    pub duration: u64,
    #[doc = "< delay between position and hardware,\n  positive for capture, negative for playback"]
    pub delay: i64,
    #[doc = "< rate difference between clock and monotonic time"]
    pub rate_diff: f64,
    #[doc = "< estimated next wakeup time in nanoseconds"]
    pub next_nsec: u64,
    #[doc = "< target rate of next cycle"]
    pub target_rate: spa_fraction,
    #[doc = "< target duration of next cycle"]
    pub target_duration: u64,
    #[doc = "< seq counter. must be equal at start and\n  end of read and lower bit must be 0"]
    pub target_seq: u32,
    pub padding: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_spa_io_clock() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_clock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_clock>(),
        160usize,
        concat!("Size of: ", stringify!(spa_io_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_clock>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_io_clock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nsec) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(nsec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate_diff) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(rate_diff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_nsec) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(next_nsec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_rate) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(target_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_duration) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(target_duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_seq) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(target_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_clock),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_video_size {
    #[doc = "< optional flags"]
    pub flags: u32,
    #[doc = "< video stride in bytes"]
    pub stride: u32,
    #[doc = "< the video size"]
    pub size: spa_rectangle,
    #[doc = "< the minimum framerate, the cycle duration is\n  always smaller to ensure there is only one\n  video frame per cycle."]
    pub framerate: spa_fraction,
    pub padding: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_spa_io_video_size() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_video_size> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_video_size>(),
        40usize,
        concat!("Size of: ", stringify!(spa_io_video_size))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_video_size>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_io_video_size))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_video_size),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_video_size),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_video_size),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_video_size),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_video_size),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " latency reporting"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_latency {
    #[doc = "< rate for min/max"]
    pub rate: spa_fraction,
    #[doc = "< min latency"]
    pub min: u64,
    #[doc = "< max latency"]
    pub max: u64,
}
#[test]
fn bindgen_test_layout_spa_io_latency() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_latency> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_latency>(),
        24usize,
        concat!("Size of: ", stringify!(spa_io_latency))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_latency>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_io_latency))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_latency),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_latency),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_latency),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " control stream, io area for SPA_IO_Control and SPA_IO_Notify"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_sequence {
    #[doc = "< sequence of timed events"]
    pub sequence: spa_pod_sequence,
}
#[test]
fn bindgen_test_layout_spa_io_sequence() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_sequence> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_sequence>(),
        16usize,
        concat!("Size of: ", stringify!(spa_io_sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_sequence>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_io_sequence))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_sequence),
            "::",
            stringify!(sequence)
        )
    );
}
#[doc = " bar and beat segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_segment_bar {
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< offset in segment of this beat"]
    pub offset: u32,
    #[doc = "< time signature numerator"]
    pub signature_num: f32,
    #[doc = "< time signature denominator"]
    pub signature_denom: f32,
    #[doc = "< beats per minute"]
    pub bpm: f64,
    #[doc = "< current beat in segment"]
    pub beat: f64,
    pub padding: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_spa_io_segment_bar() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_segment_bar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_segment_bar>(),
        64usize,
        concat!("Size of: ", stringify!(spa_io_segment_bar))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_segment_bar>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_io_segment_bar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_bar),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_bar),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature_num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_bar),
            "::",
            stringify!(signature_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature_denom) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_bar),
            "::",
            stringify!(signature_denom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpm) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_bar),
            "::",
            stringify!(bpm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_bar),
            "::",
            stringify!(beat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_bar),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " video frame segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_segment_video {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in segment"]
    pub offset: u32,
    pub framerate: spa_fraction,
    pub hours: u32,
    pub minutes: u32,
    pub seconds: u32,
    pub frames: u32,
    #[doc = "< 0 for progressive, 1 and 2 for interlaced"]
    pub field_count: u32,
    pub padding: [u32; 11usize],
}
#[test]
fn bindgen_test_layout_spa_io_segment_video() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_segment_video> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_segment_video>(),
        80usize,
        concat!("Size of: ", stringify!(spa_io_segment_video))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_segment_video>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_io_segment_video))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hours) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(hours)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minutes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(minutes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seconds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(seconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).field_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(field_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment_video),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " A segment converts a running time to a segment (stream) position.\n\n The segment position is valid when the current running time is between\n start and start + duration. The position is then\n calculated as:\n\n   (running time - start) * rate + position;\n\n Support for looping is done by specifying the LOOPING flags with a\n non-zero duration. When the running time reaches start + duration,\n duration is added to start and the loop repeats.\n\n Care has to be taken when the running time + clock.duration extends\n past the start + duration from the segment; the user should correctly\n wrap around and partially repeat the loop in the current cycle.\n\n Extra information can be placed in the segment by setting the valid flags\n and filling up the corresponding structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_segment {
    pub version: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< value of running time when this\n  info is active. Can be in the future for\n  pending changes. It does not have to be in\n  exact multiples of the clock duration."]
    pub start: u64,
    #[doc = "< duration when this info becomes invalid expressed\n  in running time. If the duration is 0, this\n  segment extends to the next segment. If the\n  segment becomes invalid and the looping flag is\n  set, the segment repeats."]
    pub duration: u64,
    #[doc = "< overall rate of the segment, can be negative for\n  backwards time reporting."]
    pub rate: f64,
    #[doc = "< The position when the running time == start.\n  can be invalid when the owner of the extra segment\n  information has not yet made the mapping."]
    pub position: u64,
    pub bar: spa_io_segment_bar,
    pub video: spa_io_segment_video,
}
#[test]
fn bindgen_test_layout_spa_io_segment() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_segment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_segment>(),
        184usize,
        concat!("Size of: ", stringify!(spa_io_segment))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_segment>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_io_segment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bar) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment),
            "::",
            stringify!(bar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_segment),
            "::",
            stringify!(video)
        )
    );
}
pub const SPA_IO_POSITION_STATE_STOPPED: spa_io_position_state = 0;
pub const SPA_IO_POSITION_STATE_STARTING: spa_io_position_state = 1;
pub const SPA_IO_POSITION_STATE_RUNNING: spa_io_position_state = 2;
pub type spa_io_position_state = ::std::os::raw::c_uint;
#[doc = " The position information adds extra meaning to the raw clock times.\n\n It is set on all nodes and the clock id will contain the clock of the\n driving node in the graph.\n\n The position information contains 1 or more segments that convert the\n raw clock times to a stream time. They are sorted based on their\n start times, and thus the order in which they will activate in\n the future. This makes it possible to look ahead in the scheduled\n segments and anticipate the changes in the timeline."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_position {
    #[doc = "< clock position of driver, always valid and\n  read only"]
    pub clock: spa_io_clock,
    #[doc = "< size of the video in the current cycle"]
    pub video: spa_io_video_size,
    #[doc = "< an offset to subtract from the clock position\n  to get a running time. This is the time that\n  the state has been in the RUNNING state and the\n  time that should be used to compare the segment\n  start values against."]
    pub offset: i64,
    #[doc = "< one of enum spa_io_position_state"]
    pub state: u32,
    #[doc = "< number of segments"]
    pub n_segments: u32,
    #[doc = "< segments"]
    pub segments: [spa_io_segment; 8usize],
}
#[test]
fn bindgen_test_layout_spa_io_position() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_position> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_position>(),
        1688usize,
        concat!("Size of: ", stringify!(spa_io_position))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_position>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_io_position))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_position),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).video) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_position),
            "::",
            stringify!(video)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_position),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_position),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_segments) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_position),
            "::",
            stringify!(n_segments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segments) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_position),
            "::",
            stringify!(segments)
        )
    );
}
#[doc = " rate matching"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_rate_match {
    #[doc = "< extra delay in samples for resampler"]
    pub delay: u32,
    #[doc = "< requested input size for resampler"]
    pub size: u32,
    #[doc = "< rate for resampler"]
    pub rate: f64,
    #[doc = "< extra flags"]
    pub flags: u32,
    pub padding: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_spa_io_rate_match() {
    const UNINIT: ::std::mem::MaybeUninit<spa_io_rate_match> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_io_rate_match>(),
        48usize,
        concat!("Size of: ", stringify!(spa_io_rate_match))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_io_rate_match>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_io_rate_match))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_rate_match),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_rate_match),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_rate_match),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_rate_match),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_io_rate_match),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = "< invalid"]
pub const SPA_PARAM_Invalid: spa_param_type = 0;
#[doc = "< property information as SPA_TYPE_OBJECT_PropInfo"]
pub const SPA_PARAM_PropInfo: spa_param_type = 1;
#[doc = "< properties as SPA_TYPE_OBJECT_Props"]
pub const SPA_PARAM_Props: spa_param_type = 2;
#[doc = "< available formats as SPA_TYPE_OBJECT_Format"]
pub const SPA_PARAM_EnumFormat: spa_param_type = 3;
#[doc = "< configured format as SPA_TYPE_OBJECT_Format"]
pub const SPA_PARAM_Format: spa_param_type = 4;
#[doc = "< buffer configurations as SPA_TYPE_OBJECT_ParamBuffers"]
pub const SPA_PARAM_Buffers: spa_param_type = 5;
#[doc = "< allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta"]
pub const SPA_PARAM_Meta: spa_param_type = 6;
#[doc = "< configurable IO areas as SPA_TYPE_OBJECT_ParamIO"]
pub const SPA_PARAM_IO: spa_param_type = 7;
#[doc = "< profile enumeration as SPA_TYPE_OBJECT_ParamProfile"]
pub const SPA_PARAM_EnumProfile: spa_param_type = 8;
#[doc = "< profile configuration as SPA_TYPE_OBJECT_ParamProfile"]
pub const SPA_PARAM_Profile: spa_param_type = 9;
#[doc = "< port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const SPA_PARAM_EnumPortConfig: spa_param_type = 10;
#[doc = "< port configuration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const SPA_PARAM_PortConfig: spa_param_type = 11;
#[doc = "< routing enumeration as SPA_TYPE_OBJECT_ParamRoute"]
pub const SPA_PARAM_EnumRoute: spa_param_type = 12;
#[doc = "< routing configuration as SPA_TYPE_OBJECT_ParamRoute"]
pub const SPA_PARAM_Route: spa_param_type = 13;
#[doc = "< Control parameter, a SPA_TYPE_Sequence"]
pub const SPA_PARAM_Control: spa_param_type = 14;
#[doc = "< latency reporting, a SPA_TYPE_OBJECT_ParamLatency"]
pub const SPA_PARAM_Latency: spa_param_type = 15;
#[doc = "< processing latency, a SPA_TYPE_OBJECT_ParamProcessLatency"]
pub const SPA_PARAM_ProcessLatency: spa_param_type = 16;
#[doc = " different parameter types that can be queried"]
pub type spa_param_type = ::std::os::raw::c_uint;
#[doc = " information about a parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_param_info {
    #[doc = "< enum spa_param_type"]
    pub id: u32,
    pub flags: u32,
    #[doc = "< private user field. You can use this to keep\n  state."]
    pub user: u32,
    #[doc = "< private seq field. You can use this to keep\n  state of a pending update."]
    pub seq: i32,
    pub padding: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_spa_param_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_param_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_param_info>(),
        32usize,
        concat!("Size of: ", stringify!(spa_param_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_param_info>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_param_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_param_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_param_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_param_info),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_param_info),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_param_info),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = "< unknown bitorder"]
pub const SPA_PARAM_BITORDER_unknown: spa_param_bitorder = 0;
#[doc = "< most significant bit"]
pub const SPA_PARAM_BITORDER_msb: spa_param_bitorder = 1;
#[doc = "< least significant bit"]
pub const SPA_PARAM_BITORDER_lsb: spa_param_bitorder = 2;
pub type spa_param_bitorder = ::std::os::raw::c_uint;
#[doc = "< unknown availability"]
pub const SPA_PARAM_AVAILABILITY_unknown: spa_param_availability = 0;
#[doc = "< not available"]
pub const SPA_PARAM_AVAILABILITY_no: spa_param_availability = 1;
#[doc = "< available"]
pub const SPA_PARAM_AVAILABILITY_yes: spa_param_availability = 2;
pub type spa_param_availability = ::std::os::raw::c_uint;
pub const SPA_PARAM_BUFFERS_START: spa_param_buffers = 0;
#[doc = "< number of buffers (Int)"]
pub const SPA_PARAM_BUFFERS_buffers: spa_param_buffers = 1;
#[doc = "< number of data blocks per buffer (Int)"]
pub const SPA_PARAM_BUFFERS_blocks: spa_param_buffers = 2;
#[doc = "< size of a data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_size: spa_param_buffers = 3;
#[doc = "< stride of data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_stride: spa_param_buffers = 4;
#[doc = "< alignment of data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_align: spa_param_buffers = 5;
#[doc = "< possible memory types (Int, mask of enum spa_data_type)"]
pub const SPA_PARAM_BUFFERS_dataType: spa_param_buffers = 6;
#[doc = " properties for SPA_TYPE_OBJECT_ParamBuffers"]
pub type spa_param_buffers = ::std::os::raw::c_uint;
pub const SPA_PARAM_META_START: spa_param_meta = 0;
#[doc = "< the metadata, one of enum spa_meta_type (Id enum spa_meta_type)"]
pub const SPA_PARAM_META_type: spa_param_meta = 1;
#[doc = "< the expected maximum size the meta (Int)"]
pub const SPA_PARAM_META_size: spa_param_meta = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamMeta"]
pub type spa_param_meta = ::std::os::raw::c_uint;
pub const SPA_PARAM_IO_START: spa_param_io = 0;
#[doc = "< type ID, uniquely identifies the io area (Id enum spa_io_type)"]
pub const SPA_PARAM_IO_id: spa_param_io = 1;
#[doc = "< size of the io area (Int)"]
pub const SPA_PARAM_IO_size: spa_param_io = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamIO"]
pub type spa_param_io = ::std::os::raw::c_uint;
pub const SPA_PARAM_PROFILE_START: spa_param_profile = 0;
#[doc = "< profile index (Int)"]
pub const SPA_PARAM_PROFILE_index: spa_param_profile = 1;
#[doc = "< profile name (String)"]
pub const SPA_PARAM_PROFILE_name: spa_param_profile = 2;
#[doc = "< profile description (String)"]
pub const SPA_PARAM_PROFILE_description: spa_param_profile = 3;
#[doc = "< profile priority (Int)"]
pub const SPA_PARAM_PROFILE_priority: spa_param_profile = 4;
#[doc = "< availability of the profile\n  (Id enum spa_param_availability)"]
pub const SPA_PARAM_PROFILE_available: spa_param_profile = 5;
#[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
pub const SPA_PARAM_PROFILE_info: spa_param_profile = 6;
#[doc = "< node classes provided by this profile\n  (Struct(\n\t   Int : number of items following\n        Struct(\n           String : class name (eg. \"Audio/Source\"),\n           Int : number of nodes\n           String : property (eg. \"card.profile.devices\"),\n           Array of Int: device indexes\n         )*))"]
pub const SPA_PARAM_PROFILE_classes: spa_param_profile = 7;
#[doc = "< If profile should be saved (Bool)"]
pub const SPA_PARAM_PROFILE_save: spa_param_profile = 8;
#[doc = " properties for SPA_TYPE_OBJECT_ParamProfile"]
pub type spa_param_profile = ::std::os::raw::c_uint;
#[doc = "< no configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_none: spa_param_port_config_mode = 0;
#[doc = "< passthrough configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_passthrough: spa_param_port_config_mode = 1;
#[doc = "< convert configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_convert: spa_param_port_config_mode = 2;
#[doc = "< dsp configuration, depending on the external\n  format. For audio, ports will be configured for\n  the given number of channels with F32 format."]
pub const SPA_PARAM_PORT_CONFIG_MODE_dsp: spa_param_port_config_mode = 3;
pub type spa_param_port_config_mode = ::std::os::raw::c_uint;
pub const SPA_PARAM_PORT_CONFIG_START: spa_param_port_config = 0;
#[doc = "< (Id enum spa_direction) direction"]
pub const SPA_PARAM_PORT_CONFIG_direction: spa_param_port_config = 1;
#[doc = "< (Id enum spa_param_port_config_mode) mode"]
pub const SPA_PARAM_PORT_CONFIG_mode: spa_param_port_config = 2;
#[doc = "< (Bool) enable monitor output ports on input ports"]
pub const SPA_PARAM_PORT_CONFIG_monitor: spa_param_port_config = 3;
#[doc = "< (Bool) enable control ports"]
pub const SPA_PARAM_PORT_CONFIG_control: spa_param_port_config = 4;
#[doc = "< (Object) format filter"]
pub const SPA_PARAM_PORT_CONFIG_format: spa_param_port_config = 5;
#[doc = " properties for SPA_TYPE_OBJECT_ParamPortConfig"]
pub type spa_param_port_config = ::std::os::raw::c_uint;
pub const SPA_PARAM_ROUTE_START: spa_param_route = 0;
#[doc = "< index of the routing destination (Int)"]
pub const SPA_PARAM_ROUTE_index: spa_param_route = 1;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const SPA_PARAM_ROUTE_direction: spa_param_route = 2;
#[doc = "< device id (Int)"]
pub const SPA_PARAM_ROUTE_device: spa_param_route = 3;
#[doc = "< name of the routing destination (String)"]
pub const SPA_PARAM_ROUTE_name: spa_param_route = 4;
#[doc = "< description of the destination (String)"]
pub const SPA_PARAM_ROUTE_description: spa_param_route = 5;
#[doc = "< priority of the destination (Int)"]
pub const SPA_PARAM_ROUTE_priority: spa_param_route = 6;
#[doc = "< availability of the destination\n  (Id enum spa_param_availability)"]
pub const SPA_PARAM_ROUTE_available: spa_param_route = 7;
#[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
pub const SPA_PARAM_ROUTE_info: spa_param_route = 8;
#[doc = "< associated profile indexes (Array of Int)"]
pub const SPA_PARAM_ROUTE_profiles: spa_param_route = 9;
#[doc = "< properties SPA_TYPE_OBJECT_Props"]
pub const SPA_PARAM_ROUTE_props: spa_param_route = 10;
#[doc = "< associated device indexes (Array of Int)"]
pub const SPA_PARAM_ROUTE_devices: spa_param_route = 11;
#[doc = "< profile id (Int)"]
pub const SPA_PARAM_ROUTE_profile: spa_param_route = 12;
#[doc = "< If route should be saved (Bool)"]
pub const SPA_PARAM_ROUTE_save: spa_param_route = 13;
#[doc = " properties for SPA_TYPE_OBJECT_ParamRoute"]
pub type spa_param_route = ::std::os::raw::c_uint;
pub const SPA_PROP_INFO_START: spa_prop_info = 0;
#[doc = "< associated id of the property"]
pub const SPA_PROP_INFO_id: spa_prop_info = 1;
#[doc = "< name of the property"]
pub const SPA_PROP_INFO_name: spa_prop_info = 2;
#[doc = "< type and range/enums of property"]
pub const SPA_PROP_INFO_type: spa_prop_info = 3;
#[doc = "< labels of property if any, this is a\n  struct with pairs of values, the first one\n  is of the type of the property, the second\n  one is a string with a user readable label\n  for the value."]
pub const SPA_PROP_INFO_labels: spa_prop_info = 4;
#[doc = "< type of container if any (Id)"]
pub const SPA_PROP_INFO_container: spa_prop_info = 5;
#[doc = "< is part of params property (Bool)"]
pub const SPA_PROP_INFO_params: spa_prop_info = 6;
#[doc = "< User readable description"]
pub const SPA_PROP_INFO_description: spa_prop_info = 7;
#[doc = " properties of SPA_TYPE_OBJECT_PropInfo"]
pub type spa_prop_info = ::std::os::raw::c_uint;
pub const SPA_PROP_START: spa_prop = 0;
#[doc = "< an unknown property"]
pub const SPA_PROP_unknown: spa_prop = 1;
#[doc = "< device related properties"]
pub const SPA_PROP_START_Device: spa_prop = 256;
pub const SPA_PROP_device: spa_prop = 257;
pub const SPA_PROP_deviceName: spa_prop = 258;
pub const SPA_PROP_deviceFd: spa_prop = 259;
pub const SPA_PROP_card: spa_prop = 260;
pub const SPA_PROP_cardName: spa_prop = 261;
pub const SPA_PROP_minLatency: spa_prop = 262;
pub const SPA_PROP_maxLatency: spa_prop = 263;
pub const SPA_PROP_periods: spa_prop = 264;
pub const SPA_PROP_periodSize: spa_prop = 265;
pub const SPA_PROP_periodEvent: spa_prop = 266;
pub const SPA_PROP_live: spa_prop = 267;
pub const SPA_PROP_rate: spa_prop = 268;
pub const SPA_PROP_quality: spa_prop = 269;
pub const SPA_PROP_bluetoothAudioCodec: spa_prop = 270;
pub const SPA_PROP_bluetoothOffloadActive: spa_prop = 271;
#[doc = "< audio related properties"]
pub const SPA_PROP_START_Audio: spa_prop = 65536;
pub const SPA_PROP_waveType: spa_prop = 65537;
pub const SPA_PROP_frequency: spa_prop = 65538;
#[doc = "< a volume (Float), 0.0 silence, 1.0 normal"]
pub const SPA_PROP_volume: spa_prop = 65539;
#[doc = "< mute (Bool)"]
pub const SPA_PROP_mute: spa_prop = 65540;
pub const SPA_PROP_patternType: spa_prop = 65541;
pub const SPA_PROP_ditherType: spa_prop = 65542;
pub const SPA_PROP_truncate: spa_prop = 65543;
#[doc = "< a volume array, one volume per\n  channel (Array of Float)"]
pub const SPA_PROP_channelVolumes: spa_prop = 65544;
#[doc = "< a volume base (Float)"]
pub const SPA_PROP_volumeBase: spa_prop = 65545;
#[doc = "< a volume step (Float)"]
pub const SPA_PROP_volumeStep: spa_prop = 65546;
#[doc = "< a channelmap array\n (Array (Id enum spa_audio_channel))"]
pub const SPA_PROP_channelMap: spa_prop = 65547;
#[doc = "< mute (Bool)"]
pub const SPA_PROP_monitorMute: spa_prop = 65548;
#[doc = "< a volume array, one volume per\n  channel (Array of Float)"]
pub const SPA_PROP_monitorVolumes: spa_prop = 65549;
#[doc = "< delay adjustment"]
pub const SPA_PROP_latencyOffsetNsec: spa_prop = 65550;
#[doc = "< mute (Bool)"]
pub const SPA_PROP_softMute: spa_prop = 65551;
#[doc = "< a volume array, one volume per\n  channel (Array of Float)"]
pub const SPA_PROP_softVolumes: spa_prop = 65552;
#[doc = "< enabled IEC958 (S/PDIF) codecs,\n  (Array (Id enum spa_audio_iec958_codec)"]
pub const SPA_PROP_iec958Codecs: spa_prop = 65553;
#[doc = "< Samples to ramp the volume over"]
pub const SPA_PROP_volumeRampSamples: spa_prop = 65554;
#[doc = "< Step or incremental Samples to ramp\n  the volume over"]
pub const SPA_PROP_volumeRampStepSamples: spa_prop = 65555;
#[doc = "< Time in millisec to ramp the volume over"]
pub const SPA_PROP_volumeRampTime: spa_prop = 65556;
#[doc = "< Step or incremental Time in nano seconds\n  to ramp the"]
pub const SPA_PROP_volumeRampStepTime: spa_prop = 65557;
#[doc = "< the scale or graph to used to ramp the\n  volume"]
pub const SPA_PROP_volumeRampScale: spa_prop = 65558;
#[doc = "< video related properties"]
pub const SPA_PROP_START_Video: spa_prop = 131072;
pub const SPA_PROP_brightness: spa_prop = 131073;
pub const SPA_PROP_contrast: spa_prop = 131074;
pub const SPA_PROP_saturation: spa_prop = 131075;
pub const SPA_PROP_hue: spa_prop = 131076;
pub const SPA_PROP_gamma: spa_prop = 131077;
pub const SPA_PROP_exposure: spa_prop = 131078;
pub const SPA_PROP_gain: spa_prop = 131079;
pub const SPA_PROP_sharpness: spa_prop = 131080;
#[doc = "< other properties"]
pub const SPA_PROP_START_Other: spa_prop = 524288;
#[doc = "< simple control params\n    (Struct(\n\t  (String : key,\n\t   Pod    : value)*))"]
pub const SPA_PROP_params: spa_prop = 524289;
pub const SPA_PROP_START_CUSTOM: spa_prop = 16777216;
#[doc = " predefined properties for SPA_TYPE_OBJECT_Props"]
pub type spa_prop = ::std::os::raw::c_uint;
pub const SPA_MEDIA_TYPE_unknown: spa_media_type = 0;
pub const SPA_MEDIA_TYPE_audio: spa_media_type = 1;
pub const SPA_MEDIA_TYPE_video: spa_media_type = 2;
pub const SPA_MEDIA_TYPE_image: spa_media_type = 3;
pub const SPA_MEDIA_TYPE_binary: spa_media_type = 4;
pub const SPA_MEDIA_TYPE_stream: spa_media_type = 5;
pub const SPA_MEDIA_TYPE_application: spa_media_type = 6;
#[doc = " media type for SPA_TYPE_OBJECT_Format"]
pub type spa_media_type = ::std::os::raw::c_uint;
pub const SPA_MEDIA_SUBTYPE_unknown: spa_media_subtype = 0;
pub const SPA_MEDIA_SUBTYPE_raw: spa_media_subtype = 1;
pub const SPA_MEDIA_SUBTYPE_dsp: spa_media_subtype = 2;
pub const SPA_MEDIA_SUBTYPE_iec958: spa_media_subtype = 3;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_dsd: spa_media_subtype = 4;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_START_Audio: spa_media_subtype = 65536;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_mp3: spa_media_subtype = 65537;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_aac: spa_media_subtype = 65538;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_vorbis: spa_media_subtype = 65539;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_wma: spa_media_subtype = 65540;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_ra: spa_media_subtype = 65541;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_sbc: spa_media_subtype = 65542;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_adpcm: spa_media_subtype = 65543;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_g723: spa_media_subtype = 65544;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_g726: spa_media_subtype = 65545;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_g729: spa_media_subtype = 65546;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_amr: spa_media_subtype = 65547;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_gsm: spa_media_subtype = 65548;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_alac: spa_media_subtype = 65549;
#[doc = " since 0.3.65"]
pub const SPA_MEDIA_SUBTYPE_flac: spa_media_subtype = 65550;
#[doc = " since 0.3.65"]
pub const SPA_MEDIA_SUBTYPE_ape: spa_media_subtype = 65551;
#[doc = " since 0.3.65"]
pub const SPA_MEDIA_SUBTYPE_opus: spa_media_subtype = 65552;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Video: spa_media_subtype = 131072;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_h264: spa_media_subtype = 131073;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mjpg: spa_media_subtype = 131074;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_dv: spa_media_subtype = 131075;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mpegts: spa_media_subtype = 131076;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_h263: spa_media_subtype = 131077;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mpeg1: spa_media_subtype = 131078;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mpeg2: spa_media_subtype = 131079;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mpeg4: spa_media_subtype = 131080;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_xvid: spa_media_subtype = 131081;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_vc1: spa_media_subtype = 131082;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_vp8: spa_media_subtype = 131083;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_vp9: spa_media_subtype = 131084;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_bayer: spa_media_subtype = 131085;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Image: spa_media_subtype = 196608;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_jpeg: spa_media_subtype = 196609;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Binary: spa_media_subtype = 262144;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Stream: spa_media_subtype = 327680;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_midi: spa_media_subtype = 327681;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Application: spa_media_subtype = 393216;
#[doc = "< control stream, data contains\n  spa_pod_sequence with control info."]
pub const SPA_MEDIA_SUBTYPE_control: spa_media_subtype = 393217;
#[doc = " media subtype for SPA_TYPE_OBJECT_Format"]
pub type spa_media_subtype = ::std::os::raw::c_uint;
pub const SPA_FORMAT_START: spa_format = 0;
#[doc = "< media type (Id enum spa_media_type)"]
pub const SPA_FORMAT_mediaType: spa_format = 1;
#[doc = "< media subtype (Id enum spa_media_subtype)"]
pub const SPA_FORMAT_mediaSubtype: spa_format = 2;
pub const SPA_FORMAT_START_Audio: spa_format = 65536;
#[doc = "< audio format, (Id enum spa_audio_format)"]
pub const SPA_FORMAT_AUDIO_format: spa_format = 65537;
#[doc = "< optional flags (Int)"]
pub const SPA_FORMAT_AUDIO_flags: spa_format = 65538;
#[doc = "< sample rate (Int)"]
pub const SPA_FORMAT_AUDIO_rate: spa_format = 65539;
#[doc = "< number of audio channels (Int)"]
pub const SPA_FORMAT_AUDIO_channels: spa_format = 65540;
#[doc = "< channel positions (Id enum spa_audio_position)"]
pub const SPA_FORMAT_AUDIO_position: spa_format = 65541;
#[doc = "< codec used (IEC958) (Id enum spa_audio_iec958_codec)"]
pub const SPA_FORMAT_AUDIO_iec958Codec: spa_format = 65542;
#[doc = "< bit order (Id enum spa_param_bitorder)"]
pub const SPA_FORMAT_AUDIO_bitorder: spa_format = 65543;
#[doc = "< Interleave bytes (Int)"]
pub const SPA_FORMAT_AUDIO_interleave: spa_format = 65544;
#[doc = "< bit rate (Int)"]
pub const SPA_FORMAT_AUDIO_bitrate: spa_format = 65545;
#[doc = "< audio data block alignment (Int)"]
pub const SPA_FORMAT_AUDIO_blockAlign: spa_format = 65546;
#[doc = "< AAC stream format, (Id enum spa_audio_aac_stream_format)"]
pub const SPA_FORMAT_AUDIO_AAC_streamFormat: spa_format = 65547;
#[doc = "< WMA profile (Id enum spa_audio_wma_profile)"]
pub const SPA_FORMAT_AUDIO_WMA_profile: spa_format = 65548;
#[doc = "< AMR band mode (Id enum spa_audio_amr_band_mode)"]
pub const SPA_FORMAT_AUDIO_AMR_bandMode: spa_format = 65549;
pub const SPA_FORMAT_START_Video: spa_format = 131072;
#[doc = "< video format (Id enum spa_video_format)"]
pub const SPA_FORMAT_VIDEO_format: spa_format = 131073;
#[doc = "< format modifier (Long)\n use only with DMA-BUF and omit for other buffer types"]
pub const SPA_FORMAT_VIDEO_modifier: spa_format = 131074;
#[doc = "< size (Rectangle)"]
pub const SPA_FORMAT_VIDEO_size: spa_format = 131075;
#[doc = "< frame rate (Fraction)"]
pub const SPA_FORMAT_VIDEO_framerate: spa_format = 131076;
#[doc = "< maximum frame rate (Fraction)"]
pub const SPA_FORMAT_VIDEO_maxFramerate: spa_format = 131077;
#[doc = "< number of views (Int)"]
pub const SPA_FORMAT_VIDEO_views: spa_format = 131078;
#[doc = "< (Id enum spa_video_interlace_mode)"]
pub const SPA_FORMAT_VIDEO_interlaceMode: spa_format = 131079;
#[doc = "< (Rectangle)"]
pub const SPA_FORMAT_VIDEO_pixelAspectRatio: spa_format = 131080;
#[doc = "< (Id enum spa_video_multiview_mode)"]
pub const SPA_FORMAT_VIDEO_multiviewMode: spa_format = 131081;
#[doc = "< (Id enum spa_video_multiview_flags)"]
pub const SPA_FORMAT_VIDEO_multiviewFlags: spa_format = 131082;
#[doc = "< /Id enum spa_video_chroma_site)"]
pub const SPA_FORMAT_VIDEO_chromaSite: spa_format = 131083;
#[doc = "< /Id enum spa_video_color_range)"]
pub const SPA_FORMAT_VIDEO_colorRange: spa_format = 131084;
#[doc = "< /Id enum spa_video_color_matrix)"]
pub const SPA_FORMAT_VIDEO_colorMatrix: spa_format = 131085;
#[doc = "< /Id enum spa_video_transfer_function)"]
pub const SPA_FORMAT_VIDEO_transferFunction: spa_format = 131086;
#[doc = "< /Id enum spa_video_color_primaries)"]
pub const SPA_FORMAT_VIDEO_colorPrimaries: spa_format = 131087;
#[doc = "< (Int)"]
pub const SPA_FORMAT_VIDEO_profile: spa_format = 131088;
#[doc = "< (Int)"]
pub const SPA_FORMAT_VIDEO_level: spa_format = 131089;
#[doc = "< (Id enum spa_h264_stream_format)"]
pub const SPA_FORMAT_VIDEO_H264_streamFormat: spa_format = 131090;
#[doc = "< (Id enum spa_h264_alignment)"]
pub const SPA_FORMAT_VIDEO_H264_alignment: spa_format = 131091;
pub const SPA_FORMAT_START_Image: spa_format = 196608;
pub const SPA_FORMAT_START_Binary: spa_format = 262144;
pub const SPA_FORMAT_START_Stream: spa_format = 327680;
pub const SPA_FORMAT_START_Application: spa_format = 393216;
#[doc = " properties for audio SPA_TYPE_OBJECT_Format"]
pub type spa_format = ::std::os::raw::c_uint;
pub const SPA_AUDIO_FORMAT_UNKNOWN: spa_audio_format = 0;
pub const SPA_AUDIO_FORMAT_ENCODED: spa_audio_format = 1;
pub const SPA_AUDIO_FORMAT_START_Interleaved: spa_audio_format = 256;
pub const SPA_AUDIO_FORMAT_S8: spa_audio_format = 257;
pub const SPA_AUDIO_FORMAT_U8: spa_audio_format = 258;
pub const SPA_AUDIO_FORMAT_S16_LE: spa_audio_format = 259;
pub const SPA_AUDIO_FORMAT_S16_BE: spa_audio_format = 260;
pub const SPA_AUDIO_FORMAT_U16_LE: spa_audio_format = 261;
pub const SPA_AUDIO_FORMAT_U16_BE: spa_audio_format = 262;
pub const SPA_AUDIO_FORMAT_S24_32_LE: spa_audio_format = 263;
pub const SPA_AUDIO_FORMAT_S24_32_BE: spa_audio_format = 264;
pub const SPA_AUDIO_FORMAT_U24_32_LE: spa_audio_format = 265;
pub const SPA_AUDIO_FORMAT_U24_32_BE: spa_audio_format = 266;
pub const SPA_AUDIO_FORMAT_S32_LE: spa_audio_format = 267;
pub const SPA_AUDIO_FORMAT_S32_BE: spa_audio_format = 268;
pub const SPA_AUDIO_FORMAT_U32_LE: spa_audio_format = 269;
pub const SPA_AUDIO_FORMAT_U32_BE: spa_audio_format = 270;
pub const SPA_AUDIO_FORMAT_S24_LE: spa_audio_format = 271;
pub const SPA_AUDIO_FORMAT_S24_BE: spa_audio_format = 272;
pub const SPA_AUDIO_FORMAT_U24_LE: spa_audio_format = 273;
pub const SPA_AUDIO_FORMAT_U24_BE: spa_audio_format = 274;
pub const SPA_AUDIO_FORMAT_S20_LE: spa_audio_format = 275;
pub const SPA_AUDIO_FORMAT_S20_BE: spa_audio_format = 276;
pub const SPA_AUDIO_FORMAT_U20_LE: spa_audio_format = 277;
pub const SPA_AUDIO_FORMAT_U20_BE: spa_audio_format = 278;
pub const SPA_AUDIO_FORMAT_S18_LE: spa_audio_format = 279;
pub const SPA_AUDIO_FORMAT_S18_BE: spa_audio_format = 280;
pub const SPA_AUDIO_FORMAT_U18_LE: spa_audio_format = 281;
pub const SPA_AUDIO_FORMAT_U18_BE: spa_audio_format = 282;
pub const SPA_AUDIO_FORMAT_F32_LE: spa_audio_format = 283;
pub const SPA_AUDIO_FORMAT_F32_BE: spa_audio_format = 284;
pub const SPA_AUDIO_FORMAT_F64_LE: spa_audio_format = 285;
pub const SPA_AUDIO_FORMAT_F64_BE: spa_audio_format = 286;
pub const SPA_AUDIO_FORMAT_ULAW: spa_audio_format = 287;
pub const SPA_AUDIO_FORMAT_ALAW: spa_audio_format = 288;
pub const SPA_AUDIO_FORMAT_START_Planar: spa_audio_format = 512;
pub const SPA_AUDIO_FORMAT_U8P: spa_audio_format = 513;
pub const SPA_AUDIO_FORMAT_S16P: spa_audio_format = 514;
pub const SPA_AUDIO_FORMAT_S24_32P: spa_audio_format = 515;
pub const SPA_AUDIO_FORMAT_S32P: spa_audio_format = 516;
pub const SPA_AUDIO_FORMAT_S24P: spa_audio_format = 517;
pub const SPA_AUDIO_FORMAT_F32P: spa_audio_format = 518;
pub const SPA_AUDIO_FORMAT_F64P: spa_audio_format = 519;
pub const SPA_AUDIO_FORMAT_S8P: spa_audio_format = 520;
pub const SPA_AUDIO_FORMAT_START_Other: spa_audio_format = 1024;
pub const SPA_AUDIO_FORMAT_DSP_S32: spa_audio_format = 515;
pub const SPA_AUDIO_FORMAT_DSP_F32: spa_audio_format = 518;
pub const SPA_AUDIO_FORMAT_DSP_F64: spa_audio_format = 519;
pub const SPA_AUDIO_FORMAT_S16: spa_audio_format = 259;
pub const SPA_AUDIO_FORMAT_U16: spa_audio_format = 261;
pub const SPA_AUDIO_FORMAT_S24_32: spa_audio_format = 263;
pub const SPA_AUDIO_FORMAT_U24_32: spa_audio_format = 265;
pub const SPA_AUDIO_FORMAT_S32: spa_audio_format = 267;
pub const SPA_AUDIO_FORMAT_U32: spa_audio_format = 269;
pub const SPA_AUDIO_FORMAT_S24: spa_audio_format = 271;
pub const SPA_AUDIO_FORMAT_U24: spa_audio_format = 273;
pub const SPA_AUDIO_FORMAT_S20: spa_audio_format = 275;
pub const SPA_AUDIO_FORMAT_U20: spa_audio_format = 277;
pub const SPA_AUDIO_FORMAT_S18: spa_audio_format = 279;
pub const SPA_AUDIO_FORMAT_U18: spa_audio_format = 281;
pub const SPA_AUDIO_FORMAT_F32: spa_audio_format = 283;
pub const SPA_AUDIO_FORMAT_F64: spa_audio_format = 285;
pub const SPA_AUDIO_FORMAT_S16_OE: spa_audio_format = 260;
pub const SPA_AUDIO_FORMAT_U16_OE: spa_audio_format = 262;
pub const SPA_AUDIO_FORMAT_S24_32_OE: spa_audio_format = 264;
pub const SPA_AUDIO_FORMAT_U24_32_OE: spa_audio_format = 266;
pub const SPA_AUDIO_FORMAT_S32_OE: spa_audio_format = 268;
pub const SPA_AUDIO_FORMAT_U32_OE: spa_audio_format = 270;
pub const SPA_AUDIO_FORMAT_S24_OE: spa_audio_format = 272;
pub const SPA_AUDIO_FORMAT_U24_OE: spa_audio_format = 274;
pub const SPA_AUDIO_FORMAT_S20_OE: spa_audio_format = 276;
pub const SPA_AUDIO_FORMAT_U20_OE: spa_audio_format = 278;
pub const SPA_AUDIO_FORMAT_S18_OE: spa_audio_format = 280;
pub const SPA_AUDIO_FORMAT_U18_OE: spa_audio_format = 282;
pub const SPA_AUDIO_FORMAT_F32_OE: spa_audio_format = 284;
pub const SPA_AUDIO_FORMAT_F64_OE: spa_audio_format = 286;
pub type spa_audio_format = ::std::os::raw::c_uint;
#[doc = "< unspecified"]
pub const SPA_AUDIO_CHANNEL_UNKNOWN: spa_audio_channel = 0;
#[doc = "< N/A, silent"]
pub const SPA_AUDIO_CHANNEL_NA: spa_audio_channel = 1;
#[doc = "< mono stream"]
pub const SPA_AUDIO_CHANNEL_MONO: spa_audio_channel = 2;
#[doc = "< front left"]
pub const SPA_AUDIO_CHANNEL_FL: spa_audio_channel = 3;
#[doc = "< front right"]
pub const SPA_AUDIO_CHANNEL_FR: spa_audio_channel = 4;
#[doc = "< front center"]
pub const SPA_AUDIO_CHANNEL_FC: spa_audio_channel = 5;
#[doc = "< LFE"]
pub const SPA_AUDIO_CHANNEL_LFE: spa_audio_channel = 6;
#[doc = "< side left"]
pub const SPA_AUDIO_CHANNEL_SL: spa_audio_channel = 7;
#[doc = "< side right"]
pub const SPA_AUDIO_CHANNEL_SR: spa_audio_channel = 8;
#[doc = "< front left center"]
pub const SPA_AUDIO_CHANNEL_FLC: spa_audio_channel = 9;
#[doc = "< front right center"]
pub const SPA_AUDIO_CHANNEL_FRC: spa_audio_channel = 10;
#[doc = "< rear center"]
pub const SPA_AUDIO_CHANNEL_RC: spa_audio_channel = 11;
#[doc = "< rear left"]
pub const SPA_AUDIO_CHANNEL_RL: spa_audio_channel = 12;
#[doc = "< rear right"]
pub const SPA_AUDIO_CHANNEL_RR: spa_audio_channel = 13;
#[doc = "< top center"]
pub const SPA_AUDIO_CHANNEL_TC: spa_audio_channel = 14;
#[doc = "< top front left"]
pub const SPA_AUDIO_CHANNEL_TFL: spa_audio_channel = 15;
#[doc = "< top front center"]
pub const SPA_AUDIO_CHANNEL_TFC: spa_audio_channel = 16;
#[doc = "< top front right"]
pub const SPA_AUDIO_CHANNEL_TFR: spa_audio_channel = 17;
#[doc = "< top rear left"]
pub const SPA_AUDIO_CHANNEL_TRL: spa_audio_channel = 18;
#[doc = "< top rear center"]
pub const SPA_AUDIO_CHANNEL_TRC: spa_audio_channel = 19;
#[doc = "< top rear right"]
pub const SPA_AUDIO_CHANNEL_TRR: spa_audio_channel = 20;
#[doc = "< rear left center"]
pub const SPA_AUDIO_CHANNEL_RLC: spa_audio_channel = 21;
#[doc = "< rear right center"]
pub const SPA_AUDIO_CHANNEL_RRC: spa_audio_channel = 22;
#[doc = "< front left wide"]
pub const SPA_AUDIO_CHANNEL_FLW: spa_audio_channel = 23;
#[doc = "< front right wide"]
pub const SPA_AUDIO_CHANNEL_FRW: spa_audio_channel = 24;
#[doc = "< LFE 2"]
pub const SPA_AUDIO_CHANNEL_LFE2: spa_audio_channel = 25;
#[doc = "< front left high"]
pub const SPA_AUDIO_CHANNEL_FLH: spa_audio_channel = 26;
#[doc = "< front center high"]
pub const SPA_AUDIO_CHANNEL_FCH: spa_audio_channel = 27;
#[doc = "< front right high"]
pub const SPA_AUDIO_CHANNEL_FRH: spa_audio_channel = 28;
#[doc = "< top front left center"]
pub const SPA_AUDIO_CHANNEL_TFLC: spa_audio_channel = 29;
#[doc = "< top front right center"]
pub const SPA_AUDIO_CHANNEL_TFRC: spa_audio_channel = 30;
#[doc = "< top side left"]
pub const SPA_AUDIO_CHANNEL_TSL: spa_audio_channel = 31;
#[doc = "< top side right"]
pub const SPA_AUDIO_CHANNEL_TSR: spa_audio_channel = 32;
#[doc = "< left LFE"]
pub const SPA_AUDIO_CHANNEL_LLFE: spa_audio_channel = 33;
#[doc = "< right LFE"]
pub const SPA_AUDIO_CHANNEL_RLFE: spa_audio_channel = 34;
#[doc = "< bottom center"]
pub const SPA_AUDIO_CHANNEL_BC: spa_audio_channel = 35;
#[doc = "< bottom left center"]
pub const SPA_AUDIO_CHANNEL_BLC: spa_audio_channel = 36;
#[doc = "< bottom right center"]
pub const SPA_AUDIO_CHANNEL_BRC: spa_audio_channel = 37;
#[doc = "< aux channels"]
pub const SPA_AUDIO_CHANNEL_START_Aux: spa_audio_channel = 4096;
pub const SPA_AUDIO_CHANNEL_AUX0: spa_audio_channel = 4096;
pub const SPA_AUDIO_CHANNEL_AUX1: spa_audio_channel = 4097;
pub const SPA_AUDIO_CHANNEL_AUX2: spa_audio_channel = 4098;
pub const SPA_AUDIO_CHANNEL_AUX3: spa_audio_channel = 4099;
pub const SPA_AUDIO_CHANNEL_AUX4: spa_audio_channel = 4100;
pub const SPA_AUDIO_CHANNEL_AUX5: spa_audio_channel = 4101;
pub const SPA_AUDIO_CHANNEL_AUX6: spa_audio_channel = 4102;
pub const SPA_AUDIO_CHANNEL_AUX7: spa_audio_channel = 4103;
pub const SPA_AUDIO_CHANNEL_AUX8: spa_audio_channel = 4104;
pub const SPA_AUDIO_CHANNEL_AUX9: spa_audio_channel = 4105;
pub const SPA_AUDIO_CHANNEL_AUX10: spa_audio_channel = 4106;
pub const SPA_AUDIO_CHANNEL_AUX11: spa_audio_channel = 4107;
pub const SPA_AUDIO_CHANNEL_AUX12: spa_audio_channel = 4108;
pub const SPA_AUDIO_CHANNEL_AUX13: spa_audio_channel = 4109;
pub const SPA_AUDIO_CHANNEL_AUX14: spa_audio_channel = 4110;
pub const SPA_AUDIO_CHANNEL_AUX15: spa_audio_channel = 4111;
pub const SPA_AUDIO_CHANNEL_AUX16: spa_audio_channel = 4112;
pub const SPA_AUDIO_CHANNEL_AUX17: spa_audio_channel = 4113;
pub const SPA_AUDIO_CHANNEL_AUX18: spa_audio_channel = 4114;
pub const SPA_AUDIO_CHANNEL_AUX19: spa_audio_channel = 4115;
pub const SPA_AUDIO_CHANNEL_AUX20: spa_audio_channel = 4116;
pub const SPA_AUDIO_CHANNEL_AUX21: spa_audio_channel = 4117;
pub const SPA_AUDIO_CHANNEL_AUX22: spa_audio_channel = 4118;
pub const SPA_AUDIO_CHANNEL_AUX23: spa_audio_channel = 4119;
pub const SPA_AUDIO_CHANNEL_AUX24: spa_audio_channel = 4120;
pub const SPA_AUDIO_CHANNEL_AUX25: spa_audio_channel = 4121;
pub const SPA_AUDIO_CHANNEL_AUX26: spa_audio_channel = 4122;
pub const SPA_AUDIO_CHANNEL_AUX27: spa_audio_channel = 4123;
pub const SPA_AUDIO_CHANNEL_AUX28: spa_audio_channel = 4124;
pub const SPA_AUDIO_CHANNEL_AUX29: spa_audio_channel = 4125;
pub const SPA_AUDIO_CHANNEL_AUX30: spa_audio_channel = 4126;
pub const SPA_AUDIO_CHANNEL_AUX31: spa_audio_channel = 4127;
pub const SPA_AUDIO_CHANNEL_AUX32: spa_audio_channel = 4128;
pub const SPA_AUDIO_CHANNEL_AUX33: spa_audio_channel = 4129;
pub const SPA_AUDIO_CHANNEL_AUX34: spa_audio_channel = 4130;
pub const SPA_AUDIO_CHANNEL_AUX35: spa_audio_channel = 4131;
pub const SPA_AUDIO_CHANNEL_AUX36: spa_audio_channel = 4132;
pub const SPA_AUDIO_CHANNEL_AUX37: spa_audio_channel = 4133;
pub const SPA_AUDIO_CHANNEL_AUX38: spa_audio_channel = 4134;
pub const SPA_AUDIO_CHANNEL_AUX39: spa_audio_channel = 4135;
pub const SPA_AUDIO_CHANNEL_AUX40: spa_audio_channel = 4136;
pub const SPA_AUDIO_CHANNEL_AUX41: spa_audio_channel = 4137;
pub const SPA_AUDIO_CHANNEL_AUX42: spa_audio_channel = 4138;
pub const SPA_AUDIO_CHANNEL_AUX43: spa_audio_channel = 4139;
pub const SPA_AUDIO_CHANNEL_AUX44: spa_audio_channel = 4140;
pub const SPA_AUDIO_CHANNEL_AUX45: spa_audio_channel = 4141;
pub const SPA_AUDIO_CHANNEL_AUX46: spa_audio_channel = 4142;
pub const SPA_AUDIO_CHANNEL_AUX47: spa_audio_channel = 4143;
pub const SPA_AUDIO_CHANNEL_AUX48: spa_audio_channel = 4144;
pub const SPA_AUDIO_CHANNEL_AUX49: spa_audio_channel = 4145;
pub const SPA_AUDIO_CHANNEL_AUX50: spa_audio_channel = 4146;
pub const SPA_AUDIO_CHANNEL_AUX51: spa_audio_channel = 4147;
pub const SPA_AUDIO_CHANNEL_AUX52: spa_audio_channel = 4148;
pub const SPA_AUDIO_CHANNEL_AUX53: spa_audio_channel = 4149;
pub const SPA_AUDIO_CHANNEL_AUX54: spa_audio_channel = 4150;
pub const SPA_AUDIO_CHANNEL_AUX55: spa_audio_channel = 4151;
pub const SPA_AUDIO_CHANNEL_AUX56: spa_audio_channel = 4152;
pub const SPA_AUDIO_CHANNEL_AUX57: spa_audio_channel = 4153;
pub const SPA_AUDIO_CHANNEL_AUX58: spa_audio_channel = 4154;
pub const SPA_AUDIO_CHANNEL_AUX59: spa_audio_channel = 4155;
pub const SPA_AUDIO_CHANNEL_AUX60: spa_audio_channel = 4156;
pub const SPA_AUDIO_CHANNEL_AUX61: spa_audio_channel = 4157;
pub const SPA_AUDIO_CHANNEL_AUX62: spa_audio_channel = 4158;
pub const SPA_AUDIO_CHANNEL_AUX63: spa_audio_channel = 4159;
#[doc = "< aux channels"]
pub const SPA_AUDIO_CHANNEL_LAST_Aux: spa_audio_channel = 8191;
pub const SPA_AUDIO_CHANNEL_START_Custom: spa_audio_channel = 65536;
pub type spa_audio_channel = ::std::os::raw::c_uint;
pub const SPA_AUDIO_VOLUME_RAMP_INVALID: spa_audio_volume_ramp_scale = 0;
pub const SPA_AUDIO_VOLUME_RAMP_LINEAR: spa_audio_volume_ramp_scale = 1;
pub const SPA_AUDIO_VOLUME_RAMP_CUBIC: spa_audio_volume_ramp_scale = 2;
pub type spa_audio_volume_ramp_scale = ::std::os::raw::c_uint;
#[doc = " Audio information description"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_raw {
    pub format: spa_audio_format,
    pub flags: u32,
    pub rate: u32,
    pub channels: u32,
    pub position: [u32; 64usize],
}
#[test]
fn bindgen_test_layout_spa_audio_info_raw() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_raw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_raw>(),
        272usize,
        concat!("Size of: ", stringify!(spa_audio_info_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_raw>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_raw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_raw),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_raw),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_raw),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_raw),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_raw),
            "::",
            stringify!(position)
        )
    );
}
pub const SPA_AUDIO_IEC958_CODEC_UNKNOWN: spa_audio_iec958_codec = 0;
pub const SPA_AUDIO_IEC958_CODEC_PCM: spa_audio_iec958_codec = 1;
pub const SPA_AUDIO_IEC958_CODEC_DTS: spa_audio_iec958_codec = 2;
pub const SPA_AUDIO_IEC958_CODEC_AC3: spa_audio_iec958_codec = 3;
#[doc = "< MPEG-1 or MPEG-2 (Part 3, not AAC)"]
pub const SPA_AUDIO_IEC958_CODEC_MPEG: spa_audio_iec958_codec = 4;
#[doc = "< MPEG-2 AAC"]
pub const SPA_AUDIO_IEC958_CODEC_MPEG2_AAC: spa_audio_iec958_codec = 5;
pub const SPA_AUDIO_IEC958_CODEC_EAC3: spa_audio_iec958_codec = 6;
#[doc = "< Dolby TrueHD"]
pub const SPA_AUDIO_IEC958_CODEC_TRUEHD: spa_audio_iec958_codec = 7;
#[doc = "< DTS-HD Master Audio"]
pub const SPA_AUDIO_IEC958_CODEC_DTSHD: spa_audio_iec958_codec = 8;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_iec958_codec = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_iec958 {
    pub codec: spa_audio_iec958_codec,
    pub flags: u32,
    pub rate: u32,
}
#[test]
fn bindgen_test_layout_spa_audio_info_iec958() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_iec958> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_iec958>(),
        12usize,
        concat!("Size of: ", stringify!(spa_audio_info_iec958))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_iec958>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_iec958))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_iec958),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_iec958),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_iec958),
            "::",
            stringify!(rate)
        )
    );
}
pub const SPA_AUDIO_MP3_CHANNEL_MODE_UNKNOWN: spa_audio_mp3_channel_mode = 0;
pub const SPA_AUDIO_MP3_CHANNEL_MODE_MONO: spa_audio_mp3_channel_mode = 1;
pub const SPA_AUDIO_MP3_CHANNEL_MODE_STEREO: spa_audio_mp3_channel_mode = 2;
pub const SPA_AUDIO_MP3_CHANNEL_MODE_JOINTSTEREO: spa_audio_mp3_channel_mode = 3;
pub const SPA_AUDIO_MP3_CHANNEL_MODE_DUAL: spa_audio_mp3_channel_mode = 4;
pub type spa_audio_mp3_channel_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_mp3 {
    pub rate: u32,
    pub channels: u32,
}
#[test]
fn bindgen_test_layout_spa_audio_info_mp3() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_mp3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_mp3>(),
        8usize,
        concat!("Size of: ", stringify!(spa_audio_info_mp3))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_mp3>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_mp3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_mp3),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_mp3),
            "::",
            stringify!(channels)
        )
    );
}
pub const SPA_AUDIO_AAC_STREAM_FORMAT_UNKNOWN: spa_audio_aac_stream_format = 0;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_RAW: spa_audio_aac_stream_format = 1;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP2ADTS: spa_audio_aac_stream_format = 2;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP4ADTS: spa_audio_aac_stream_format = 3;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP4LOAS: spa_audio_aac_stream_format = 4;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP4LATM: spa_audio_aac_stream_format = 5;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_ADIF: spa_audio_aac_stream_format = 6;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP4FF: spa_audio_aac_stream_format = 7;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_CUSTOM: spa_audio_aac_stream_format = 65536;
pub type spa_audio_aac_stream_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_aac {
    pub rate: u32,
    pub channels: u32,
    pub bitrate: u32,
    pub stream_format: spa_audio_aac_stream_format,
}
#[test]
fn bindgen_test_layout_spa_audio_info_aac() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_aac> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_aac>(),
        16usize,
        concat!("Size of: ", stringify!(spa_audio_info_aac))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_aac>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_aac))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_aac),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_aac),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_aac),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_format) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_aac),
            "::",
            stringify!(stream_format)
        )
    );
}
pub const SPA_AUDIO_WMA_PROFILE_UNKNOWN: spa_audio_wma_profile = 0;
pub const SPA_AUDIO_WMA_PROFILE_WMA7: spa_audio_wma_profile = 1;
pub const SPA_AUDIO_WMA_PROFILE_WMA8: spa_audio_wma_profile = 2;
pub const SPA_AUDIO_WMA_PROFILE_WMA9: spa_audio_wma_profile = 3;
pub const SPA_AUDIO_WMA_PROFILE_WMA10: spa_audio_wma_profile = 4;
pub const SPA_AUDIO_WMA_PROFILE_WMA9_PRO: spa_audio_wma_profile = 5;
pub const SPA_AUDIO_WMA_PROFILE_WMA9_LOSSLESS: spa_audio_wma_profile = 6;
pub const SPA_AUDIO_WMA_PROFILE_WMA10_LOSSLESS: spa_audio_wma_profile = 7;
pub const SPA_AUDIO_WMA_PROFILE_CUSTOM: spa_audio_wma_profile = 65536;
pub type spa_audio_wma_profile = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_wma {
    pub rate: u32,
    pub channels: u32,
    pub bitrate: u32,
    pub block_align: u32,
    pub profile: spa_audio_wma_profile,
}
#[test]
fn bindgen_test_layout_spa_audio_info_wma() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_wma> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_wma>(),
        20usize,
        concat!("Size of: ", stringify!(spa_audio_info_wma))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_wma>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_wma))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_wma),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_wma),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_wma),
            "::",
            stringify!(bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block_align) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_wma),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_wma),
            "::",
            stringify!(profile)
        )
    );
}
pub const SPA_AUDIO_AMR_BAND_MODE_UNKNOWN: spa_audio_amr_band_mode = 0;
pub const SPA_AUDIO_AMR_BAND_MODE_NB: spa_audio_amr_band_mode = 1;
pub const SPA_AUDIO_AMR_BAND_MODE_WB: spa_audio_amr_band_mode = 2;
pub type spa_audio_amr_band_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_amr {
    pub rate: u32,
    pub channels: u32,
    pub band_mode: spa_audio_amr_band_mode,
}
#[test]
fn bindgen_test_layout_spa_audio_info_amr() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_amr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_amr>(),
        12usize,
        concat!("Size of: ", stringify!(spa_audio_info_amr))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_amr>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_amr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_amr),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_amr),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).band_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_amr),
            "::",
            stringify!(band_mode)
        )
    );
}
pub const SPA_BLUETOOTH_AUDIO_CODEC_START: spa_bluetooth_audio_codec = 0;
pub const SPA_BLUETOOTH_AUDIO_CODEC_SBC: spa_bluetooth_audio_codec = 1;
pub const SPA_BLUETOOTH_AUDIO_CODEC_SBC_XQ: spa_bluetooth_audio_codec = 2;
pub const SPA_BLUETOOTH_AUDIO_CODEC_MPEG: spa_bluetooth_audio_codec = 3;
pub const SPA_BLUETOOTH_AUDIO_CODEC_AAC: spa_bluetooth_audio_codec = 4;
pub const SPA_BLUETOOTH_AUDIO_CODEC_APTX: spa_bluetooth_audio_codec = 5;
pub const SPA_BLUETOOTH_AUDIO_CODEC_APTX_HD: spa_bluetooth_audio_codec = 6;
pub const SPA_BLUETOOTH_AUDIO_CODEC_LDAC: spa_bluetooth_audio_codec = 7;
pub const SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL: spa_bluetooth_audio_codec = 8;
pub const SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL_DUPLEX: spa_bluetooth_audio_codec = 9;
pub const SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM: spa_bluetooth_audio_codec = 10;
pub const SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM_DUPLEX: spa_bluetooth_audio_codec = 11;
pub const SPA_BLUETOOTH_AUDIO_CODEC_LC3PLUS_HR: spa_bluetooth_audio_codec = 12;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05: spa_bluetooth_audio_codec = 13;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_51: spa_bluetooth_audio_codec = 14;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_71: spa_bluetooth_audio_codec = 15;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_DUPLEX: spa_bluetooth_audio_codec = 16;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_PRO: spa_bluetooth_audio_codec = 17;
pub const SPA_BLUETOOTH_AUDIO_CODEC_CVSD: spa_bluetooth_audio_codec = 256;
pub const SPA_BLUETOOTH_AUDIO_CODEC_MSBC: spa_bluetooth_audio_codec = 257;
pub const SPA_BLUETOOTH_AUDIO_CODEC_LC3: spa_bluetooth_audio_codec = 512;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_bluetooth_audio_codec = ::std::os::raw::c_uint;
#[doc = "< unknown cositing"]
pub const SPA_VIDEO_CHROMA_SITE_UNKNOWN: spa_video_chroma_site = 0;
#[doc = "< no cositing"]
pub const SPA_VIDEO_CHROMA_SITE_NONE: spa_video_chroma_site = 1;
#[doc = "< chroma is horizontally cosited"]
pub const SPA_VIDEO_CHROMA_SITE_H_COSITED: spa_video_chroma_site = 2;
#[doc = "< chroma is vertically cosited"]
pub const SPA_VIDEO_CHROMA_SITE_V_COSITED: spa_video_chroma_site = 4;
#[doc = "< chroma samples are sited on alternate lines"]
pub const SPA_VIDEO_CHROMA_SITE_ALT_LINE: spa_video_chroma_site = 8;
#[doc = " chroma samples cosited with luma samples"]
pub const SPA_VIDEO_CHROMA_SITE_COSITED: spa_video_chroma_site = 6;
#[doc = " jpeg style cositing, also for mpeg1 and mjpeg"]
pub const SPA_VIDEO_CHROMA_SITE_JPEG: spa_video_chroma_site = 1;
#[doc = " mpeg2 style cositing"]
pub const SPA_VIDEO_CHROMA_SITE_MPEG2: spa_video_chroma_site = 2;
pub const SPA_VIDEO_CHROMA_SITE_DV: spa_video_chroma_site = 14;
#[doc = " Various Chroma settings."]
pub type spa_video_chroma_site = ::std::os::raw::c_uint;
#[doc = "< unknown range"]
pub const SPA_VIDEO_COLOR_RANGE_UNKNOWN: spa_video_color_range = 0;
#[doc = "< [0..255] for 8 bit components"]
pub const SPA_VIDEO_COLOR_RANGE_0_255: spa_video_color_range = 1;
#[doc = "< [16..235] for 8 bit components. Chroma has\n[16..240] range."]
pub const SPA_VIDEO_COLOR_RANGE_16_235: spa_video_color_range = 2;
#[doc = " Possible color range values. These constants are defined for 8 bit color\n values and can be scaled for other bit depths."]
pub type spa_video_color_range = ::std::os::raw::c_uint;
#[doc = "< unknown matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_UNKNOWN: spa_video_color_matrix = 0;
#[doc = "< identity matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_RGB: spa_video_color_matrix = 1;
#[doc = "< FCC color matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_FCC: spa_video_color_matrix = 2;
#[doc = "< ITU BT.709 color matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_BT709: spa_video_color_matrix = 3;
#[doc = "< ITU BT.601 color matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_BT601: spa_video_color_matrix = 4;
#[doc = "< SMTPE  240M color matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_SMPTE240M: spa_video_color_matrix = 5;
#[doc = "<  ITU-R BT.2020 color matrix. since 1.6."]
pub const SPA_VIDEO_COLOR_MATRIX_BT2020: spa_video_color_matrix = 6;
#[doc = " The color matrix is used to convert between Y'PbPr and\n non-linear RGB (R'G'B')"]
pub type spa_video_color_matrix = ::std::os::raw::c_uint;
#[doc = "< unknown transfer function"]
pub const SPA_VIDEO_TRANSFER_UNKNOWN: spa_video_transfer_function = 0;
#[doc = "< linear RGB, gamma 1.0 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA10: spa_video_transfer_function = 1;
#[doc = "< Gamma 1.8 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA18: spa_video_transfer_function = 2;
#[doc = "< Gamma 2.0 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA20: spa_video_transfer_function = 3;
#[doc = "< Gamma 2.2 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA22: spa_video_transfer_function = 4;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower range"]
pub const SPA_VIDEO_TRANSFER_BT709: spa_video_transfer_function = 5;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower range"]
pub const SPA_VIDEO_TRANSFER_SMPTE240M: spa_video_transfer_function = 6;
#[doc = "< Gamma 2.4 curve with a linear segment in the lower range"]
pub const SPA_VIDEO_TRANSFER_SRGB: spa_video_transfer_function = 7;
#[doc = "< Gamma 2.8 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA28: spa_video_transfer_function = 8;
#[doc = "< Logarithmic transfer characteristic 100:1 range"]
pub const SPA_VIDEO_TRANSFER_LOG100: spa_video_transfer_function = 9;
#[doc = "< Logarithmic transfer characteristic 316.22777:1 range"]
pub const SPA_VIDEO_TRANSFER_LOG316: spa_video_transfer_function = 10;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower\n   range. Used for BT.2020 with 12 bits per\n   component. \\since 1.6."]
pub const SPA_VIDEO_TRANSFER_BT2020_12: spa_video_transfer_function = 11;
#[doc = "< Gamma 2.19921875. \\since 1.8"]
pub const SPA_VIDEO_TRANSFER_ADOBERGB: spa_video_transfer_function = 12;
#[doc = " The video transfer function defines the formula for converting between\n non-linear RGB (R'G'B') and linear RGB"]
pub type spa_video_transfer_function = ::std::os::raw::c_uint;
#[doc = "< unknown color primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_UNKNOWN: spa_video_color_primaries = 0;
#[doc = "< BT709 primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_BT709: spa_video_color_primaries = 1;
#[doc = "< BT470M primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_BT470M: spa_video_color_primaries = 2;
#[doc = "< BT470BG primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_BT470BG: spa_video_color_primaries = 3;
#[doc = "< SMPTE170M primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_SMPTE170M: spa_video_color_primaries = 4;
#[doc = "< SMPTE240M primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_SMPTE240M: spa_video_color_primaries = 5;
#[doc = "< Generic film"]
pub const SPA_VIDEO_COLOR_PRIMARIES_FILM: spa_video_color_primaries = 6;
#[doc = "< BT2020 primaries. \\since 1.6."]
pub const SPA_VIDEO_COLOR_PRIMARIES_BT2020: spa_video_color_primaries = 7;
#[doc = "< Adobe RGB primaries. \\since 1.8"]
pub const SPA_VIDEO_COLOR_PRIMARIES_ADOBERGB: spa_video_color_primaries = 8;
#[doc = " The color primaries define the how to transform linear RGB values to and from\n the CIE XYZ colorspace."]
pub type spa_video_color_primaries = ::std::os::raw::c_uint;
#[doc = " spa_video_colorimetry:\n\n Structure describing the color info."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_colorimetry {
    #[doc = "< The color range. This is the valid range for the\n    samples. It is used to convert the samples to Y'PbPr\n    values."]
    pub range: spa_video_color_range,
    #[doc = "< the color matrix. Used to convert between Y'PbPr and\n    non-linear RGB (R'G'B')"]
    pub matrix: spa_video_color_matrix,
    #[doc = "< The transfer function. Used to convert between\n   R'G'B' and RGB"]
    pub transfer: spa_video_transfer_function,
    #[doc = "< Color primaries. Used to convert between R'G'B'\n   and CIE XYZ"]
    pub primaries: spa_video_color_primaries,
}
#[test]
fn bindgen_test_layout_spa_video_colorimetry() {
    const UNINIT: ::std::mem::MaybeUninit<spa_video_colorimetry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_video_colorimetry>(),
        16usize,
        concat!("Size of: ", stringify!(spa_video_colorimetry))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_video_colorimetry>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_video_colorimetry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_colorimetry),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_colorimetry),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_colorimetry),
            "::",
            stringify!(transfer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primaries) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_colorimetry),
            "::",
            stringify!(primaries)
        )
    );
}
#[doc = " A special value indicating no multiview information. Used in spa_video_info and other\n places to indicate that no specific multiview handling has been requested or provided.\n This value is never carried on caps."]
pub const SPA_VIDEO_MULTIVIEW_MODE_NONE: spa_video_multiview_mode = -1;
#[doc = "< All frames are monoscopic"]
pub const SPA_VIDEO_MULTIVIEW_MODE_MONO: spa_video_multiview_mode = 0;
#[doc = "< All frames represent a left-eye view"]
pub const SPA_VIDEO_MULTIVIEW_MODE_LEFT: spa_video_multiview_mode = 1;
#[doc = "< All frames represent a right-eye view"]
pub const SPA_VIDEO_MULTIVIEW_MODE_RIGHT: spa_video_multiview_mode = 2;
#[doc = "< Left and right eye views are provided\n   in the left and right half of the frame\n   respectively."]
pub const SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE: spa_video_multiview_mode = 3;
#[doc = "< Left and right eye views are provided\n   in the left and right half of the\n   frame, but have been sampled using\n   quincunx method, with half-pixel offset\n   between the 2 views."]
pub const SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX: spa_video_multiview_mode = 4;
#[doc = "< Alternating vertical columns of pixels\n   represent the left and right eye view\n   respectively."]
pub const SPA_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED: spa_video_multiview_mode = 5;
#[doc = "< Alternating horizontal rows of pixels\n   represent the left and right eye view\n   respectively."]
pub const SPA_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED: spa_video_multiview_mode = 6;
#[doc = "< The top half of the frame contains the\n   left eye, and the bottom half the right\n   eye."]
pub const SPA_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM: spa_video_multiview_mode = 7;
#[doc = "< Pixels are arranged with alternating\n   pixels representing left and right eye\n   views in a checkerboard fashion."]
pub const SPA_VIDEO_MULTIVIEW_MODE_CHECKERBOARD: spa_video_multiview_mode = 8;
#[doc = "< Left and right eye views are provided\n   in separate frames alternately."]
pub const SPA_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME: spa_video_multiview_mode = 32;
#[doc = "< Multipleindependent views are\n   provided in separate frames in\n   sequence. This method only applies to\n   raw video buffers at the moment.\n   Specific view identification is via\n   \\ref spa_video_multiview_meta on raw\n   video buffers."]
pub const SPA_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME: spa_video_multiview_mode = 33;
#[doc = "< Multiple views are provided as separate\n   \\ref spa_data framebuffers attached\n   to each \\ref spa_buffer, described\n   by the \\ref spa_video_multiview_meta"]
pub const SPA_VIDEO_MULTIVIEW_MODE_SEPARATED: spa_video_multiview_mode = 34;
#[doc = " All possible stereoscopic 3D and multiview representations.\n In conjunction with \\ref spa_video_multiview_flags, describes how\n multiview content is being transported in the stream."]
pub type spa_video_multiview_mode = ::std::os::raw::c_int;
#[doc = "< No flags"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_NONE: spa_video_multiview_flags = 0;
#[doc = "< For stereo streams, the normal arrangement\n   of left and right views is reversed"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST: spa_video_multiview_flags = 1;
#[doc = "< The left view is vertically mirrored"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED: spa_video_multiview_flags = 2;
#[doc = "< The left view is horizontally mirrored"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED: spa_video_multiview_flags = 4;
#[doc = "< The right view is vertically mirrored"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED: spa_video_multiview_flags = 8;
#[doc = "< The right view is horizontally mirrored"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED: spa_video_multiview_flags = 16;
#[doc = "< For frame-packed multiview\n   modes, indicates that the individual\n   views have been encoded with half the true\n   width or height and should be scaled back\n   up for display. This flag is used for\n   overriding input layout interpretation\n   by adjusting pixel-aspect-ratio.\n   For side-by-side, column interleaved or\n   checkerboard packings, the\n   pixel width will be doubled.\n   For row interleaved and\n   top-bottom encodings, pixel height will\n   be doubled"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT: spa_video_multiview_flags = 16384;
#[doc = "< The video stream contains both\n   mono and multiview portions,\n   signalled on each buffer by the\n   absence or presence of the\n   \\ref SPA_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW\n   buffer flag."]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO: spa_video_multiview_flags = 32768;
#[doc = " spa_video_multiview_flags are used to indicate extra properties of a\n stereo/multiview stream beyond the frame layout and buffer mapping\n that is conveyed in the \\ref spa_video_multiview_mode."]
pub type spa_video_multiview_flags = ::std::os::raw::c_uint;
pub const SPA_VIDEO_FORMAT_UNKNOWN: spa_video_format = 0;
pub const SPA_VIDEO_FORMAT_ENCODED: spa_video_format = 1;
pub const SPA_VIDEO_FORMAT_I420: spa_video_format = 2;
pub const SPA_VIDEO_FORMAT_YV12: spa_video_format = 3;
pub const SPA_VIDEO_FORMAT_YUY2: spa_video_format = 4;
pub const SPA_VIDEO_FORMAT_UYVY: spa_video_format = 5;
pub const SPA_VIDEO_FORMAT_AYUV: spa_video_format = 6;
pub const SPA_VIDEO_FORMAT_RGBx: spa_video_format = 7;
pub const SPA_VIDEO_FORMAT_BGRx: spa_video_format = 8;
pub const SPA_VIDEO_FORMAT_xRGB: spa_video_format = 9;
pub const SPA_VIDEO_FORMAT_xBGR: spa_video_format = 10;
pub const SPA_VIDEO_FORMAT_RGBA: spa_video_format = 11;
pub const SPA_VIDEO_FORMAT_BGRA: spa_video_format = 12;
pub const SPA_VIDEO_FORMAT_ARGB: spa_video_format = 13;
pub const SPA_VIDEO_FORMAT_ABGR: spa_video_format = 14;
pub const SPA_VIDEO_FORMAT_RGB: spa_video_format = 15;
pub const SPA_VIDEO_FORMAT_BGR: spa_video_format = 16;
pub const SPA_VIDEO_FORMAT_Y41B: spa_video_format = 17;
pub const SPA_VIDEO_FORMAT_Y42B: spa_video_format = 18;
pub const SPA_VIDEO_FORMAT_YVYU: spa_video_format = 19;
pub const SPA_VIDEO_FORMAT_Y444: spa_video_format = 20;
pub const SPA_VIDEO_FORMAT_v210: spa_video_format = 21;
pub const SPA_VIDEO_FORMAT_v216: spa_video_format = 22;
pub const SPA_VIDEO_FORMAT_NV12: spa_video_format = 23;
pub const SPA_VIDEO_FORMAT_NV21: spa_video_format = 24;
pub const SPA_VIDEO_FORMAT_GRAY8: spa_video_format = 25;
pub const SPA_VIDEO_FORMAT_GRAY16_BE: spa_video_format = 26;
pub const SPA_VIDEO_FORMAT_GRAY16_LE: spa_video_format = 27;
pub const SPA_VIDEO_FORMAT_v308: spa_video_format = 28;
pub const SPA_VIDEO_FORMAT_RGB16: spa_video_format = 29;
pub const SPA_VIDEO_FORMAT_BGR16: spa_video_format = 30;
pub const SPA_VIDEO_FORMAT_RGB15: spa_video_format = 31;
pub const SPA_VIDEO_FORMAT_BGR15: spa_video_format = 32;
pub const SPA_VIDEO_FORMAT_UYVP: spa_video_format = 33;
pub const SPA_VIDEO_FORMAT_A420: spa_video_format = 34;
pub const SPA_VIDEO_FORMAT_RGB8P: spa_video_format = 35;
pub const SPA_VIDEO_FORMAT_YUV9: spa_video_format = 36;
pub const SPA_VIDEO_FORMAT_YVU9: spa_video_format = 37;
pub const SPA_VIDEO_FORMAT_IYU1: spa_video_format = 38;
pub const SPA_VIDEO_FORMAT_ARGB64: spa_video_format = 39;
pub const SPA_VIDEO_FORMAT_AYUV64: spa_video_format = 40;
pub const SPA_VIDEO_FORMAT_r210: spa_video_format = 41;
pub const SPA_VIDEO_FORMAT_I420_10BE: spa_video_format = 42;
pub const SPA_VIDEO_FORMAT_I420_10LE: spa_video_format = 43;
pub const SPA_VIDEO_FORMAT_I422_10BE: spa_video_format = 44;
pub const SPA_VIDEO_FORMAT_I422_10LE: spa_video_format = 45;
pub const SPA_VIDEO_FORMAT_Y444_10BE: spa_video_format = 46;
pub const SPA_VIDEO_FORMAT_Y444_10LE: spa_video_format = 47;
pub const SPA_VIDEO_FORMAT_GBR: spa_video_format = 48;
pub const SPA_VIDEO_FORMAT_GBR_10BE: spa_video_format = 49;
pub const SPA_VIDEO_FORMAT_GBR_10LE: spa_video_format = 50;
pub const SPA_VIDEO_FORMAT_NV16: spa_video_format = 51;
pub const SPA_VIDEO_FORMAT_NV24: spa_video_format = 52;
pub const SPA_VIDEO_FORMAT_NV12_64Z32: spa_video_format = 53;
pub const SPA_VIDEO_FORMAT_A420_10BE: spa_video_format = 54;
pub const SPA_VIDEO_FORMAT_A420_10LE: spa_video_format = 55;
pub const SPA_VIDEO_FORMAT_A422_10BE: spa_video_format = 56;
pub const SPA_VIDEO_FORMAT_A422_10LE: spa_video_format = 57;
pub const SPA_VIDEO_FORMAT_A444_10BE: spa_video_format = 58;
pub const SPA_VIDEO_FORMAT_A444_10LE: spa_video_format = 59;
pub const SPA_VIDEO_FORMAT_NV61: spa_video_format = 60;
pub const SPA_VIDEO_FORMAT_P010_10BE: spa_video_format = 61;
pub const SPA_VIDEO_FORMAT_P010_10LE: spa_video_format = 62;
pub const SPA_VIDEO_FORMAT_IYU2: spa_video_format = 63;
pub const SPA_VIDEO_FORMAT_VYUY: spa_video_format = 64;
pub const SPA_VIDEO_FORMAT_GBRA: spa_video_format = 65;
pub const SPA_VIDEO_FORMAT_GBRA_10BE: spa_video_format = 66;
pub const SPA_VIDEO_FORMAT_GBRA_10LE: spa_video_format = 67;
pub const SPA_VIDEO_FORMAT_GBR_12BE: spa_video_format = 68;
pub const SPA_VIDEO_FORMAT_GBR_12LE: spa_video_format = 69;
pub const SPA_VIDEO_FORMAT_GBRA_12BE: spa_video_format = 70;
pub const SPA_VIDEO_FORMAT_GBRA_12LE: spa_video_format = 71;
pub const SPA_VIDEO_FORMAT_I420_12BE: spa_video_format = 72;
pub const SPA_VIDEO_FORMAT_I420_12LE: spa_video_format = 73;
pub const SPA_VIDEO_FORMAT_I422_12BE: spa_video_format = 74;
pub const SPA_VIDEO_FORMAT_I422_12LE: spa_video_format = 75;
pub const SPA_VIDEO_FORMAT_Y444_12BE: spa_video_format = 76;
pub const SPA_VIDEO_FORMAT_Y444_12LE: spa_video_format = 77;
pub const SPA_VIDEO_FORMAT_RGBA_F16: spa_video_format = 78;
pub const SPA_VIDEO_FORMAT_RGBA_F32: spa_video_format = 79;
#[doc = "< 32-bit x:R:G:B 2:10:10:10 little endian"]
pub const SPA_VIDEO_FORMAT_xRGB_210LE: spa_video_format = 80;
#[doc = "< 32-bit x:B:G:R 2:10:10:10 little endian"]
pub const SPA_VIDEO_FORMAT_xBGR_210LE: spa_video_format = 81;
#[doc = "< 32-bit R:G:B:x 10:10:10:2 little endian"]
pub const SPA_VIDEO_FORMAT_RGBx_102LE: spa_video_format = 82;
#[doc = "< 32-bit B:G:R:x 10:10:10:2 little endian"]
pub const SPA_VIDEO_FORMAT_BGRx_102LE: spa_video_format = 83;
#[doc = "< 32-bit A:R:G:B 2:10:10:10 little endian"]
pub const SPA_VIDEO_FORMAT_ARGB_210LE: spa_video_format = 84;
#[doc = "< 32-bit A:B:G:R 2:10:10:10 little endian"]
pub const SPA_VIDEO_FORMAT_ABGR_210LE: spa_video_format = 85;
#[doc = "< 32-bit R:G:B:A 10:10:10:2 little endian"]
pub const SPA_VIDEO_FORMAT_RGBA_102LE: spa_video_format = 86;
#[doc = "< 32-bit B:G:R:A 10:10:10:2 little endian"]
pub const SPA_VIDEO_FORMAT_BGRA_102LE: spa_video_format = 87;
pub const SPA_VIDEO_FORMAT_DSP_F32: spa_video_format = 79;
#[doc = " Video formats\n\n The components are in general described in big-endian order. There are some\n exceptions (e.g. RGB15 and RGB16) which use the host endianness.\n\n Most of the formats are identical to their GStreamer equivalent. See the\n GStreamer video formats documentation for more details:\n\n https://gstreamer.freedesktop.org/documentation/additional/design/mediatype-video-raw.html#formats"]
pub type spa_video_format = ::std::os::raw::c_uint;
#[doc = "< no flags"]
pub const SPA_VIDEO_FLAG_NONE: spa_video_flags = 0;
#[doc = "< a variable fps is selected, fps_n and fps_d\n   denote the maximum fps of the video"]
pub const SPA_VIDEO_FLAG_VARIABLE_FPS: spa_video_flags = 1;
#[doc = "< Each color has been scaled by the alpha value."]
pub const SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA: spa_video_flags = 2;
#[doc = "< use the format modifier"]
pub const SPA_VIDEO_FLAG_MODIFIER: spa_video_flags = 4;
#[doc = " Extra video flags"]
pub type spa_video_flags = ::std::os::raw::c_uint;
#[doc = "< all frames are progressive"]
pub const SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE: spa_video_interlace_mode = 0;
#[doc = "< 2 fields are interleaved in one video frame.\n Extra buffer flags describe the field order."]
pub const SPA_VIDEO_INTERLACE_MODE_INTERLEAVED: spa_video_interlace_mode = 1;
#[doc = "< frames contains both interlaced and progressive\n   video, the buffer flags describe the frame and\n   fields."]
pub const SPA_VIDEO_INTERLACE_MODE_MIXED: spa_video_interlace_mode = 2;
#[doc = "< 2 fields are stored in one buffer, use the\n   frame ID to get access to the required\n   field. For multiview (the 'views'\n   property > 1) the fields of view N can\n   be found at frame ID (N * 2) and (N *\n   2) + 1. Each field has only half the\n   amount of lines as noted in the height\n   property. This mode requires multiple\n   spa_data to describe the fields."]
pub const SPA_VIDEO_INTERLACE_MODE_FIELDS: spa_video_interlace_mode = 3;
#[doc = " The possible values of the #spa_video_interlace_mode describing the interlace\n mode of the stream."]
pub type spa_video_interlace_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_info_raw {
    #[doc = "< the format"]
    pub format: spa_video_format,
    #[doc = "< extra video flags"]
    pub flags: u32,
    #[doc = "< format modifier\n only used with DMA-BUF"]
    pub modifier: u64,
    #[doc = "< the frame size of the video"]
    pub size: spa_rectangle,
    #[doc = "< the framerate of the video, 0/1 means variable rate"]
    pub framerate: spa_fraction,
    #[doc = "< the maximum framerate of the video. This is only valid when\n\\ref framerate is 0/1"]
    pub max_framerate: spa_fraction,
    #[doc = "< the number of views in this video"]
    pub views: u32,
    #[doc = "< the interlace mode"]
    pub interlace_mode: spa_video_interlace_mode,
    #[doc = "< the pixel aspect ratio"]
    pub pixel_aspect_ratio: spa_fraction,
    #[doc = "< multiview mode"]
    pub multiview_mode: spa_video_multiview_mode,
    #[doc = "< multiview flags"]
    pub multiview_flags: spa_video_multiview_flags,
    #[doc = "< the chroma siting"]
    pub chroma_site: spa_video_chroma_site,
    #[doc = "< the color range. This is the valid range for the samples.\n   It is used to convert the samples to Y'PbPr values."]
    pub color_range: spa_video_color_range,
    #[doc = "< the color matrix. Used to convert between Y'PbPr and\n   non-linear RGB (R'G'B')"]
    pub color_matrix: spa_video_color_matrix,
    #[doc = "< the transfer function. used to convert between R'G'B' and RGB"]
    pub transfer_function: spa_video_transfer_function,
    #[doc = "< color primaries. used to convert between R'G'B' and CIE XYZ"]
    pub color_primaries: spa_video_color_primaries,
}
#[test]
fn bindgen_test_layout_spa_video_info_raw() {
    const UNINIT: ::std::mem::MaybeUninit<spa_video_info_raw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_video_info_raw>(),
        88usize,
        concat!("Size of: ", stringify!(spa_video_info_raw))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_video_info_raw>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_video_info_raw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_framerate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(max_framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).views) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(views)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interlace_mode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(interlace_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_aspect_ratio) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(pixel_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiview_mode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(multiview_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiview_flags) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(multiview_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_site) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(chroma_site)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_matrix) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(color_matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transfer_function) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(transfer_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_primaries) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_raw),
            "::",
            stringify!(color_primaries)
        )
    );
}
pub const SPA_PARAM_LATENCY_START: spa_param_latency = 0;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const SPA_PARAM_LATENCY_direction: spa_param_latency = 1;
#[doc = "< min latency relative to quantum (Float)"]
pub const SPA_PARAM_LATENCY_minQuantum: spa_param_latency = 2;
#[doc = "< max latency relative to quantum (Float)"]
pub const SPA_PARAM_LATENCY_maxQuantum: spa_param_latency = 3;
#[doc = "< min latency (Int) relative to rate"]
pub const SPA_PARAM_LATENCY_minRate: spa_param_latency = 4;
#[doc = "< max latency (Int) relative to rate"]
pub const SPA_PARAM_LATENCY_maxRate: spa_param_latency = 5;
#[doc = "< min latency (Long) in nanoseconds"]
pub const SPA_PARAM_LATENCY_minNs: spa_param_latency = 6;
#[doc = "< max latency (Long) in nanoseconds"]
pub const SPA_PARAM_LATENCY_maxNs: spa_param_latency = 7;
#[doc = " properties for SPA_TYPE_OBJECT_ParamLatency"]
pub type spa_param_latency = ::std::os::raw::c_uint;
#[doc = " helper structure for managing latency objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_latency_info {
    pub direction: spa_direction,
    pub min_quantum: f32,
    pub max_quantum: f32,
    pub min_rate: u32,
    pub max_rate: u32,
    pub min_ns: u64,
    pub max_ns: u64,
}
#[test]
fn bindgen_test_layout_spa_latency_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_latency_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_latency_info>(),
        40usize,
        concat!("Size of: ", stringify!(spa_latency_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_latency_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_latency_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_latency_info),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_quantum) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_latency_info),
            "::",
            stringify!(min_quantum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_quantum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_latency_info),
            "::",
            stringify!(max_quantum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_rate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_latency_info),
            "::",
            stringify!(min_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_rate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_latency_info),
            "::",
            stringify!(max_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_ns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_latency_info),
            "::",
            stringify!(min_ns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_ns) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_latency_info),
            "::",
            stringify!(max_ns)
        )
    );
}
pub const SPA_PARAM_PROCESS_LATENCY_START: spa_param_process_latency = 0;
#[doc = "< latency relative to quantum (Float)"]
pub const SPA_PARAM_PROCESS_LATENCY_quantum: spa_param_process_latency = 1;
#[doc = "< latency (Int) relative to rate"]
pub const SPA_PARAM_PROCESS_LATENCY_rate: spa_param_process_latency = 2;
#[doc = "< latency (Long) in nanoseconds"]
pub const SPA_PARAM_PROCESS_LATENCY_ns: spa_param_process_latency = 3;
#[doc = " properties for SPA_TYPE_OBJECT_ParamProcessLatency"]
pub type spa_param_process_latency = ::std::os::raw::c_uint;
#[doc = " Helper structure for managing process latency objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_process_latency_info {
    pub quantum: f32,
    pub rate: u32,
    pub ns: u64,
}
#[test]
fn bindgen_test_layout_spa_process_latency_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_process_latency_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_process_latency_info>(),
        16usize,
        concat!("Size of: ", stringify!(spa_process_latency_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_process_latency_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_process_latency_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quantum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_process_latency_info),
            "::",
            stringify!(quantum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_process_latency_info),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_process_latency_info),
            "::",
            stringify!(ns)
        )
    );
}
pub const SPA_PROFILER_START: spa_profiler = 0;
#[doc = "< driver related profiler properties"]
pub const SPA_PROFILER_START_Driver: spa_profiler = 65536;
#[doc = "< Generic info, counter and CPU load,\n (Struct(\n      Long : counter,\n      Float : cpu_load fast,\n      Float : cpu_load medium,\n      Float : cpu_load slow),\n      Int : xrun-count))"]
pub const SPA_PROFILER_info: spa_profiler = 65537;
#[doc = "< clock information\n  (Struct(\n      Int : clock flags,\n      Int : clock id,\n      String: clock name,\n      Long : clock nsec,\n      Fraction : clock rate,\n      Long : clock position,\n      Long : clock duration,\n      Long : clock delay,\n      Double : clock rate_diff,\n      Long : clock next_nsec))"]
pub const SPA_PROFILER_clock: spa_profiler = 65538;
#[doc = "< generic driver info block\n  (Struct(\n      Int : driver_id,\n      String : name,\n      Long : driver prev_signal,\n      Long : driver signal,\n      Long : driver awake,\n      Long : driver finish,\n      Int : driver status),\n      Fraction : latency))"]
pub const SPA_PROFILER_driverBlock: spa_profiler = 65539;
#[doc = "< follower related profiler properties"]
pub const SPA_PROFILER_START_Follower: spa_profiler = 131072;
#[doc = "< generic follower info block\n  (Struct(\n      Int : id,\n      String : name,\n      Long : prev_signal,\n      Long : signal,\n      Long : awake,\n      Long : finish,\n      Int : status,\n      Fraction : latency))"]
pub const SPA_PROFILER_followerBlock: spa_profiler = 131073;
pub const SPA_PROFILER_START_CUSTOM: spa_profiler = 16777216;
#[doc = " properties for SPA_TYPE_OBJECT_Profiler"]
pub type spa_profiler = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_debug_context {
    pub log: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut spa_debug_context, fmt: *const ::std::os::raw::c_char, ...),
    >,
}
#[test]
fn bindgen_test_layout_spa_debug_context() {
    const UNINIT: ::std::mem::MaybeUninit<spa_debug_context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_debug_context>(),
        8usize,
        concat!("Size of: ", stringify!(spa_debug_context))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_debug_context>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_debug_context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_debug_context),
            "::",
            stringify!(log)
        )
    );
}
#[doc = " \\addtogroup spa_dict\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dict_item {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_spa_dict_item() {
    const UNINIT: ::std::mem::MaybeUninit<spa_dict_item> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_dict_item>(),
        16usize,
        concat!("Size of: ", stringify!(spa_dict_item))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_dict_item>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_dict_item))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dict_item),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dict_item),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dict {
    pub flags: u32,
    pub n_items: u32,
    pub items: *const spa_dict_item,
}
#[test]
fn bindgen_test_layout_spa_dict() {
    const UNINIT: ::std::mem::MaybeUninit<spa_dict> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_dict>(),
        16usize,
        concat!("Size of: ", stringify!(spa_dict))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_dict>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_dict))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dict),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_items) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dict),
            "::",
            stringify!(n_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dict),
            "::",
            stringify!(items)
        )
    );
}
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_frame {
    pub pod: spa_pod,
    pub parent: *mut spa_pod_frame,
    pub offset: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_spa_pod_frame() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_frame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_frame>(),
        24usize,
        concat!("Size of: ", stringify!(spa_pod_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_frame),
            "::",
            stringify!(pod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_frame),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_frame),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_frame),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_parser_state {
    pub offset: u32,
    pub flags: u32,
    pub frame: *mut spa_pod_frame,
}
#[test]
fn bindgen_test_layout_spa_pod_parser_state() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_parser_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_parser_state>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_parser_state))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_parser_state>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_parser_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_parser_state),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_parser_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_parser_state),
            "::",
            stringify!(frame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_parser {
    pub data: *const ::std::os::raw::c_void,
    pub size: u32,
    pub _padding: u32,
    pub state: spa_pod_parser_state,
}
#[test]
fn bindgen_test_layout_spa_pod_parser() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_parser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_parser>(),
        32usize,
        concat!("Size of: ", stringify!(spa_pod_parser))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_parser>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_parser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_parser),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_parser),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_parser),
            "::",
            stringify!(_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_parser),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_strbuf {
    pub buffer: *mut ::std::os::raw::c_char,
    pub maxsize: usize,
    pub pos: usize,
}
#[test]
fn bindgen_test_layout_spa_strbuf() {
    const UNINIT: ::std::mem::MaybeUninit<spa_strbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_strbuf>(),
        24usize,
        concat!("Size of: ", stringify!(spa_strbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_strbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_strbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_strbuf),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_strbuf),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_strbuf),
            "::",
            stringify!(pos)
        )
    );
}
#[doc = " \\addtogroup spa_list List\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_list {
    pub next: *mut spa_list,
    pub prev: *mut spa_list,
}
#[test]
fn bindgen_test_layout_spa_list() {
    const UNINIT: ::std::mem::MaybeUninit<spa_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_list>(),
        16usize,
        concat!("Size of: ", stringify!(spa_list))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_list>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_list),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_list),
            "::",
            stringify!(prev)
        )
    );
}
#[doc = " \\struct spa_callbacks\n Callbacks, contains the structure with functions and the data passed\n to the functions.  The structure should also contain a version field that\n is checked."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_callbacks {
    pub funcs: *const ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_callbacks() {
    const UNINIT: ::std::mem::MaybeUninit<spa_callbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_callbacks>(),
        16usize,
        concat!("Size of: ", stringify!(spa_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_callbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_callbacks),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_callbacks),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\struct spa_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_interface {
    pub type_: *const ::std::os::raw::c_char,
    pub version: u32,
    pub cb: spa_callbacks,
}
#[test]
fn bindgen_test_layout_spa_interface() {
    const UNINIT: ::std::mem::MaybeUninit<spa_interface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_interface>(),
        32usize,
        concat!("Size of: ", stringify!(spa_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_interface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_interface),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_interface),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_interface),
            "::",
            stringify!(cb)
        )
    );
}
#[doc = " \\struct spa_hook_list\n A list of hooks. This struct is primarily used by\n implementation that use multiple caller-provided \\ref spa_hook."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_hook_list {
    pub list: spa_list,
}
#[test]
fn bindgen_test_layout_spa_hook_list() {
    const UNINIT: ::std::mem::MaybeUninit<spa_hook_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_hook_list>(),
        16usize,
        concat!("Size of: ", stringify!(spa_hook_list))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_hook_list>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_hook_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_hook_list),
            "::",
            stringify!(list)
        )
    );
}
#[doc = " \\struct spa_hook\n A hook, contains the structure with functions and the data passed\n to the functions.\n\n A hook should be treated as opaque by the caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_hook {
    pub link: spa_list,
    pub cb: spa_callbacks,
    #[doc = " callback and data for the hook list, private to the\n hook_list implementor"]
    pub removed: ::std::option::Option<unsafe extern "C" fn(hook: *mut spa_hook)>,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_hook() {
    const UNINIT: ::std::mem::MaybeUninit<spa_hook> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_hook>(),
        48usize,
        concat!("Size of: ", stringify!(spa_hook))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_hook>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_hook))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_hook),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_hook),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_hook),
            "::",
            stringify!(removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_hook),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_node() {
    const UNINIT: ::std::mem::MaybeUninit<spa_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_node>(),
        32usize,
        concat!("Size of: ", stringify!(spa_node))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_node>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node),
            "::",
            stringify!(iface)
        )
    );
}
#[doc = " Node information structure\n\n Contains the basic node information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node_info {
    pub max_input_ports: u32,
    pub max_output_ports: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra node properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[test]
fn bindgen_test_layout_spa_node_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_node_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_node_info>(),
        48usize,
        concat!("Size of: ", stringify!(spa_node_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_node_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_node_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_input_ports) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_info),
            "::",
            stringify!(max_input_ports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_output_ports) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_info),
            "::",
            stringify!(max_output_ports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_info),
            "::",
            stringify!(change_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_info),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_info),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_params) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_info),
            "::",
            stringify!(n_params)
        )
    );
}
#[doc = " Port information structure\n\n Contains the basic port information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_port_info {
    pub change_mask: u64,
    #[doc = "< port flags"]
    pub flags: u64,
    #[doc = "< rate of sequence numbers on port"]
    pub rate: spa_fraction,
    #[doc = "< extra port properties"]
    pub props: *const spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[test]
fn bindgen_test_layout_spa_port_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_port_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_port_info>(),
        48usize,
        concat!("Size of: ", stringify!(spa_port_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_port_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_port_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_port_info),
            "::",
            stringify!(change_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_port_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_port_info),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_port_info),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_port_info),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_params) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_port_info),
            "::",
            stringify!(n_params)
        )
    );
}
#[doc = " an error result"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_node_error {
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_spa_result_node_error() {
    const UNINIT: ::std::mem::MaybeUninit<spa_result_node_error> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_result_node_error>(),
        8usize,
        concat!("Size of: ", stringify!(spa_result_node_error))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_result_node_error>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_result_node_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_node_error),
            "::",
            stringify!(message)
        )
    );
}
#[doc = " the result of enum_params or port_enum_params."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_node_params {
    #[doc = "< id of parameter"]
    pub id: u32,
    #[doc = "< index of parameter"]
    pub index: u32,
    #[doc = "< next index of iteration"]
    pub next: u32,
    #[doc = "< the result param"]
    pub param: *mut spa_pod,
}
#[test]
fn bindgen_test_layout_spa_result_node_params() {
    const UNINIT: ::std::mem::MaybeUninit<spa_result_node_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_result_node_params>(),
        24usize,
        concat!("Size of: ", stringify!(spa_result_node_params))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_result_node_params>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_result_node_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_node_params),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_node_params),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_node_params),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_node_params),
            "::",
            stringify!(param)
        )
    );
}
#[doc = " events from the spa_node.\n\n All event are called from the main thread and multiple\n listeners can be registered for the events with\n spa_node_add_listener()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Emitted when info changes"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_node_info),
    >,
    #[doc = " Emitted when port info changes, NULL when port is removed"]
    pub port_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port: u32,
            info: *const spa_port_info,
        ),
    >,
    #[doc = " notify a result.\n\n Some methods will trigger a result event with an optional\n result of the given type. Look at the documentation of the\n method to know when to expect a result event.\n\n The result event can be called synchronously, as an event\n called from inside the method itself, in which case the seq\n number passed to the method will be passed unchanged.\n\n The result event will be called asynchronously when the\n method returned an async return value. In this case, the seq\n number in the result will match the async return value of\n the method call. Users should match the seq number from\n request to the reply."]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " \\param node a spa_node\n \\param event the event that was emitted\n\n This will be called when an out-of-bound event is notified\n on \\a node."]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
}
#[test]
fn bindgen_test_layout_spa_node_events() {
    const UNINIT: ::std::mem::MaybeUninit<spa_node_events> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_node_events>(),
        40usize,
        concat!("Size of: ", stringify!(spa_node_events))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_node_events>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_node_events))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_events),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_events),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_events),
            "::",
            stringify!(port_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_events),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_events),
            "::",
            stringify!(event)
        )
    );
}
#[doc = " Node callbacks\n\n Callbacks are called from the real-time data thread. Only\n one callback structure can be set on an spa_node."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node_callbacks {
    pub version: u32,
    #[doc = " \\param node a spa_node\n\n The node is ready for processing.\n\n When this function is NULL, synchronous operation is requested\n on the ports."]
    pub ready: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            state: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param node a spa_node\n \\param port_id an input port_id\n \\param buffer_id the buffer id to be reused\n\n The node has a buffer that can be reused.\n\n When this function is NULL, the buffers to reuse will be set in\n the io area of the input ports."]
    pub reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param data user data\n \\param trigger the timestamp in microseconds when the xrun happened\n \\param delay the amount of microseconds of xrun.\n \\param info an object with extra info (NULL for now)\n\n The node has encountered an over or underrun\n\n The info contains an object with more information"]
    pub xrun: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            trigger: u64,
            delay: u64,
            info: *mut spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_node_callbacks() {
    const UNINIT: ::std::mem::MaybeUninit<spa_node_callbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_node_callbacks>(),
        32usize,
        concat!("Size of: ", stringify!(spa_node_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_node_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_node_callbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_callbacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ready) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_callbacks),
            "::",
            stringify!(ready)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reuse_buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_callbacks),
            "::",
            stringify!(reuse_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xrun) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_callbacks),
            "::",
            stringify!(xrun)
        )
    );
}
#[doc = " Node methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node_methods {
    pub version: u32,
    #[doc = " Adds an event listener on \\a node.\n\n Setting the events will trigger the info event and a\n port_info event for each managed port on the new\n listener.\n\n \\param node a #spa_node\n \\param listener a listener\n \\param events a struct \\ref spa_node_events\n \\param data data passed as first argument in functions of \\a events\n \\return 0 on success\n\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set callbacks to on \\a node.\n if \\a callbacks is NULL, the current callbacks are removed.\n\n This function must be called from the main thread.\n\n All callbacks are called from the data thread.\n\n \\param node a spa_node\n \\param callbacks callbacks to set\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub set_callbacks: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            callbacks: *const spa_node_callbacks,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation.\n\n This method will emit the result event with the given sequence\n number synchronously or with the returned async return value\n asynchronously.\n\n Because all methods are serialized in the node, this can be used\n to wait for completion of all previous method calls.\n\n \\param seq a sequence number\n \\return 0 on success\n         -EINVAL when node is NULL\n         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a node.\n\n Parameters are identified with an \\a id. Some parameters can have\n multiple values, see the documentation of the parameter id.\n\n Parameters can be filtered by passing a non-NULL \\a filter.\n\n The function will emit the result event up to \\a max times with\n the result value. The seq in the result will either be the \\a seq\n number when executed synchronously or the async return value of\n this function when executed asynchronously.\n\n This function must be called from the main thread.\n\n \\param node a \\ref spa_node\n \\param seq a sequence number to pass to the result event when\n\tthis method is executed synchronously.\n \\param id the param id to enumerate\n \\param start the index of enumeration, pass 0 for the first item\n \\param max the maximum number of parameters to enumerate\n \\param filter and optional filter to use\n\n \\return 0 when no more items can be iterated.\n         -EINVAL when invalid arguments are given\n         -ENOENT the parameter \\a id is unknown\n         -ENOTSUP when there are no parameters\n                 implemented on \\a node\n         an async return value when the result event will be\n             emitted later."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a node.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param node a \\ref spa_node\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when node is NULL\n         -ENOTSUP when there are no parameters implemented on \\a node\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a node. This\n structure is allocated by the host and is used to exchange\n data and parameters with the node.\n\n Setting an \\a io of NULL will disable the node io.\n\n This function must be called from the main thread.\n\n \\param id the id of the io area, the available ids can be\n        enumerated with the node parameters.\n \\param data a io area memory\n \\param size the size of \\a data\n \\return 0 on success\n         -EINVAL when invalid input is given\n         -ENOENT when \\a id is unknown\n         -ENOSPC when \\a size is too small"]
    pub set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send a command to a node.\n\n Upon completion, a command might change the state of a node.\n\n This function must be called from the main thread.\n\n \\param node a  spa_node\n \\param command a spa_command\n \\return 0 on success\n         -EINVAL when node or command is NULL\n         -ENOTSUP when this node can't process commands\n         -EINVAL \\a command is an invalid command"]
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Make a new port with \\a port_id. The caller should use the lowest unused\n port id for the given \\a direction.\n\n Port ids should be between 0 and max_ports as obtained from the info\n event.\n\n This function must be called from the main thread.\n\n \\param node a  spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id an unused port id\n \\param props extra properties\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub add_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a port with \\a port_id.\n\n \\param node a  spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id a port id\n \\return 0 on success\n         -EINVAL when node is NULL or when port_id is unknown or\n\t\twhen the port can't be removed."]
    pub remove_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate all possible parameters of \\a id on \\a port_id of \\a node\n that are compatible with \\a filter.\n\n The result parameters can be queried and modified and ultimately be used\n to call port_set_param.\n\n The function will emit the result event up to \\a max times with\n the result value. The seq in the result event will either be the\n \\a seq number when executed synchronously or the async return\n value of this function when executed asynchronously.\n\n This function must be called from the main thread.\n\n \\param node a spa_node\n \\param seq a sequence number to pass to the result event when\n\tthis method is executed synchronously.\n \\param direction an spa_direction\n \\param port_id the port to query\n \\param id the parameter id to query\n \\param start the first index to query, 0 to get the first item\n \\param max the maximum number of params to query\n \\param filter a parameter filter or NULL for no filter\n\n \\return 0 when no more items can be iterated.\n         -EINVAL when invalid parameters are given\n         -ENOENT when \\a id is unknown\n         an async return value when the result event will be\n             emitted later."]
    pub port_enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a port_id of \\a node.\n\n When \\a param is NULL, the parameter will be unset.\n\n This function must be called from the main thread.\n\n \\param node a struct \\ref spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id the port to configure\n \\param id the parameter id to set\n \\param flags optional flags\n \\param param a struct \\ref spa_pod with the parameter to set\n \\return 0 on success\n         1 on success, the value of \\a param might have been\n                changed depending on \\a flags and the final value can be found by\n                doing port_enum_params.\n         -EINVAL when node is NULL or invalid arguments are given\n         -ESRCH when one of the mandatory param\n                 properties is not specified and SPA_NODE_PARAM_FLAG_FIXATE was\n                 not set in \\a flags.\n         -ESRCH when the type or size of a property is not correct.\n         -ENOENT when the param id is not found"]
    pub port_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell the port to use the given buffers\n\n When \\a flags contains SPA_NODE_BUFFERS_FLAG_ALLOC, the data\n in the buffers should point to an array of at least 1 data entry\n with the desired supported type that will be filled by this function.\n\n The port should also have a spa_io_buffers io area configured to exchange\n the buffers with the port.\n\n For an input port, all the buffers will remain dequeued.\n Once a buffer has been queued on a port in the spa_io_buffers,\n it should not be reused until the reuse_buffer callback is notified\n or when the buffer has been returned in the spa_io_buffers of\n the port.\n\n For output ports, all buffers will be queued in the port. When process\n returns SPA_STATUS_HAVE_DATA, buffers are available in one or more\n of the spa_io_buffers areas.\n\n When a buffer can be reused, port_reuse_buffer() should be called or the\n buffer_id should be placed in the spa_io_buffers area before calling\n process.\n\n Passing NULL as \\a buffers will remove the reference that the port has\n on the buffers.\n\n When this function returns async, use the spa_node_sync operation to\n wait for completion.\n\n This function must be called from the main thread.\n\n \\param object an object implementing the interface\n \\param direction a port direction\n \\param port_id a port id\n \\param flags extra flags\n \\param buffers an array of buffer pointers\n \\param n_buffers number of elements in \\a buffers\n \\return 0 on success"]
    pub port_use_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            flags: u32,
            buffers: *mut *mut spa_buffer,
            n_buffers: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a port_id. This\n structure is allocated by the host and is used to exchange\n data and parameters with the port.\n\n Setting an \\a io of NULL will disable the port io.\n\n This function must be called from the main thread.\n\n \\param direction a spa_direction\n \\param port_id a port id\n \\param id the id of the io area, the available ids can be\n        enumerated with the port parameters.\n \\param data a io area memory\n \\param size the size of \\a data\n \\return 0 on success\n         -EINVAL when invalid input is given\n         -ENOENT when \\a id is unknown\n         -ENOSPC when \\a size is too small"]
    pub port_set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell an output port to reuse a buffer.\n\n This function must be called from the data thread.\n\n \\param node a spa_node\n \\param port_id a port id\n \\param buffer_id a buffer id to reuse\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub port_reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Process the node\n\n This function must be called from the data thread.\n\n Output io areas with SPA_STATUS_NEED_DATA will recycle the\n buffers if any.\n\n Input areas with SPA_STATUS_HAVE_DATA are consumed if possible\n and the status is set to SPA_STATUS_NEED_DATA or SPA_STATUS_OK.\n\n When the node has new output buffers, the SPA_STATUS_HAVE_DATA\n bit will be set.\n\n When the node can accept new input in the next cycle, the\n SPA_STATUS_NEED_DATA bit will be set.\n\n Note that the node might return SPA_STATUS_NEED_DATA even when\n no input ports have this status. This means that the amount of\n data still available on the input ports is likely not going to\n be enough for the next cycle and the host might need to prefetch\n data for the next cycle."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_node_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_node_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_node_methods>(),
        128usize,
        concat!("Size of: ", stringify!(spa_node_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_node_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_node_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_listener) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(add_listener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_callbacks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(set_callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enum_params) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(enum_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_param) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(set_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_io) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(set_io)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_command) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(send_command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_port) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(add_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_port) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(remove_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_enum_params) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(port_enum_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_set_param) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(port_set_param)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_use_buffers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(port_use_buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_set_io) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(port_set_io)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_reuse_buffer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(port_reuse_buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_node_methods),
            "::",
            stringify!(process)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_state {
    #[doc = "< current status"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< required number of signals"]
    pub required: i32,
    #[doc = "< number of pending signals"]
    pub pending: i32,
}
#[test]
fn bindgen_test_layout_spa_graph_state() {
    const UNINIT: ::std::mem::MaybeUninit<spa_graph_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_graph_state>(),
        12usize,
        concat!("Size of: ", stringify!(spa_graph_state))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_graph_state>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_graph_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_state),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).required) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_state),
            "::",
            stringify!(required)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pending) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_state),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_link {
    pub link: spa_list,
    pub state: *mut spa_graph_state,
    pub signal: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub signal_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_graph_link() {
    const UNINIT: ::std::mem::MaybeUninit<spa_graph_link> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_graph_link>(),
        40usize,
        concat!("Size of: ", stringify!(spa_graph_link))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_graph_link>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_graph_link))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_link),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_link),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_link),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_link),
            "::",
            stringify!(signal_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph {
    pub flags: u32,
    pub parent: *mut spa_graph_node,
    pub state: *mut spa_graph_state,
    pub nodes: spa_list,
}
#[test]
fn bindgen_test_layout_spa_graph() {
    const UNINIT: ::std::mem::MaybeUninit<spa_graph> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_graph>(),
        40usize,
        concat!("Size of: ", stringify!(spa_graph))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_graph>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_graph))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph),
            "::",
            stringify!(nodes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_node_callbacks {
    pub version: u32,
    pub process: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            node: *mut spa_graph_node,
        ) -> ::std::os::raw::c_int,
    >,
    pub reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            node: *mut spa_graph_node,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_graph_node_callbacks() {
    const UNINIT: ::std::mem::MaybeUninit<spa_graph_node_callbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_graph_node_callbacks>(),
        24usize,
        concat!("Size of: ", stringify!(spa_graph_node_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_graph_node_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_graph_node_callbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node_callbacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node_callbacks),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reuse_buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node_callbacks),
            "::",
            stringify!(reuse_buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_node {
    #[doc = "< link in graph nodes list"]
    pub link: spa_list,
    #[doc = "< owner graph"]
    pub graph: *mut spa_graph,
    #[doc = "< list of input and output ports"]
    pub ports: [spa_list; 2usize],
    #[doc = "< list of links to next nodes"]
    pub links: spa_list,
    #[doc = "< node flags"]
    pub flags: u32,
    #[doc = "< state of the node"]
    pub state: *mut spa_graph_state,
    #[doc = "< link in graph"]
    pub graph_link: spa_graph_link,
    #[doc = "< subgraph or NULL"]
    pub subgraph: *mut spa_graph,
    pub callbacks: spa_callbacks,
    #[doc = "< link for scheduler"]
    pub sched_link: spa_list,
}
#[test]
fn bindgen_test_layout_spa_graph_node() {
    const UNINIT: ::std::mem::MaybeUninit<spa_graph_node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_graph_node>(),
        168usize,
        concat!("Size of: ", stringify!(spa_graph_node))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_graph_node>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_graph_node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ports) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(ports)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).links) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).graph_link) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(graph_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subgraph) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(subgraph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbacks) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_link) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_node),
            "::",
            stringify!(sched_link)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_port {
    #[doc = "< link in node port list"]
    pub link: spa_list,
    #[doc = "< owner node"]
    pub node: *mut spa_graph_node,
    #[doc = "< port direction"]
    pub direction: spa_direction,
    #[doc = "< port id"]
    pub port_id: u32,
    #[doc = "< port flags"]
    pub flags: u32,
    #[doc = "< peer"]
    pub peer: *mut spa_graph_port,
}
#[test]
fn bindgen_test_layout_spa_graph_port() {
    const UNINIT: ::std::mem::MaybeUninit<spa_graph_port> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_graph_port>(),
        48usize,
        concat!("Size of: ", stringify!(spa_graph_port))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_graph_port>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_graph_port))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_port),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_port),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_port),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_port),
            "::",
            stringify!(port_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_port),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_graph_port),
            "::",
            stringify!(peer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_device() {
    const UNINIT: ::std::mem::MaybeUninit<spa_device> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_device>(),
        32usize,
        concat!("Size of: ", stringify!(spa_device))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_device>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_device))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device),
            "::",
            stringify!(iface)
        )
    );
}
#[doc = " Information about the device and parameters it supports\n\n This information is part of the info event on a device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device_info {
    pub version: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< device properties"]
    pub props: *const spa_dict,
    #[doc = "< supported parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of elements in params"]
    pub n_params: u32,
}
#[test]
fn bindgen_test_layout_spa_device_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_device_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_device_info>(),
        48usize,
        concat!("Size of: ", stringify!(spa_device_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_device_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_device_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_info),
            "::",
            stringify!(change_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_info),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_info),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_params) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_info),
            "::",
            stringify!(n_params)
        )
    );
}
#[doc = " Information about a device object\n\n This information is part of the object_info event on the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device_object_info {
    pub version: u32,
    #[doc = "< the object type managed by this device"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< a factory name that implements the object"]
    pub factory_name: *const ::std::os::raw::c_char,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra object properties"]
    pub props: *const spa_dict,
}
#[test]
fn bindgen_test_layout_spa_device_object_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_device_object_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_device_object_info>(),
        48usize,
        concat!("Size of: ", stringify!(spa_device_object_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_device_object_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_device_object_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_object_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_object_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factory_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_object_info),
            "::",
            stringify!(factory_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_mask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_object_info),
            "::",
            stringify!(change_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_object_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_object_info),
            "::",
            stringify!(props)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_device_params {
    pub id: u32,
    pub index: u32,
    pub next: u32,
    pub param: *mut spa_pod,
}
#[test]
fn bindgen_test_layout_spa_result_device_params() {
    const UNINIT: ::std::mem::MaybeUninit<spa_result_device_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_result_device_params>(),
        24usize,
        concat!("Size of: ", stringify!(spa_result_device_params))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_result_device_params>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_result_device_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_device_params),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_device_params),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_device_params),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_device_params),
            "::",
            stringify!(param)
        )
    );
}
#[doc = " spa_device_events:\n\n Events are always emitted from the main thread"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device_events {
    pub version: u32,
    #[doc = " notify extra information about the device"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_device_info),
    >,
    #[doc = " notify a result"]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " a device event"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
    #[doc = " info changed for an object managed by the device, info is NULL when\n the object is removed"]
    pub object_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            info: *const spa_device_object_info,
        ),
    >,
}
#[test]
fn bindgen_test_layout_spa_device_events() {
    const UNINIT: ::std::mem::MaybeUninit<spa_device_events> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_device_events>(),
        40usize,
        concat!("Size of: ", stringify!(spa_device_events))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_device_events>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_device_events))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_events),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_events),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_events),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_events),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_events),
            "::",
            stringify!(object_info)
        )
    );
}
#[doc = " spa_device_methods:"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device_methods {
    pub version: u32,
    #[doc = " Set events to receive asynchronous notifications from\n the device.\n\n Setting the events will trigger the info event and an\n object_info event for each managed object on the new\n listener.\n\n \\param object a \\ref spa_device\n \\param listener a listener\n \\param events a struct \\ref spa_device_events\n \\param data data passed as first argument in functions of \\a events\n \\return 0 on success\n\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_device_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation.\n\n This method will emit the result event with the given sequence\n number synchronously or with the returned async return value\n asynchronously.\n\n Because all methods are serialized in the device, this can be used\n to wait for completion of all previous method calls.\n\n \\param seq a sequence number\n \\return 0 on success\n         -EINVAL when node is NULL\n         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a device.\n\n Parameters are identified with an \\a id. Some parameters can have\n multiple values, see the documentation of the parameter id.\n\n Parameters can be filtered by passing a non-NULL \\a filter.\n\n The result callback will be called at most \\a max times with a\n struct spa_result_device_params as the result.\n\n This function must be called from the main thread.\n\n \\param device a \\ref spa_device\n \\param seq a sequence number to pass to the result function\n \\param id the param id to enumerate\n \\param index the index of enumeration, pass 0 for the first item.\n \\param max the maximum number of items to iterate\n \\param filter and optional filter to use\n \\return 0 when there are no more parameters to enumerate\n         -EINVAL when invalid arguments are given\n         -ENOENT the parameter \\a id is unknown\n         -ENOTSUP when there are no parameters\n                 implemented on \\a device"]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a device.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param object \\ref spa_device\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when invalid arguments are given\n         -ENOTSUP when there are no parameters implemented on \\a device\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_device_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_device_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_device_methods>(),
        40usize,
        concat!("Size of: ", stringify!(spa_device_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_device_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_device_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_listener) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_methods),
            "::",
            stringify!(add_listener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_methods),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enum_params) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_methods),
            "::",
            stringify!(enum_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_param) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_device_methods),
            "::",
            stringify!(set_param)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_builder_state {
    pub offset: u32,
    pub flags: u32,
    pub frame: *mut spa_pod_frame,
}
#[test]
fn bindgen_test_layout_spa_pod_builder_state() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_builder_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_builder_state>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_builder_state))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_builder_state>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_builder_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder_state),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder_state),
            "::",
            stringify!(frame)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_builder_callbacks {
    pub version: u32,
    pub overflow: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, size: u32) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_pod_builder_callbacks() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_builder_callbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_builder_callbacks>(),
        16usize,
        concat!("Size of: ", stringify!(spa_pod_builder_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_builder_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_builder_callbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder_callbacks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder_callbacks),
            "::",
            stringify!(overflow)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_builder {
    pub data: *mut ::std::os::raw::c_void,
    pub size: u32,
    pub _padding: u32,
    pub state: spa_pod_builder_state,
    pub callbacks: spa_callbacks,
}
#[test]
fn bindgen_test_layout_spa_pod_builder() {
    const UNINIT: ::std::mem::MaybeUninit<spa_pod_builder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_pod_builder>(),
        48usize,
        concat!("Size of: ", stringify!(spa_pod_builder))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_pod_builder>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_pod_builder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder),
            "::",
            stringify!(_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbacks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_pod_builder),
            "::",
            stringify!(callbacks)
        )
    );
}
#[doc = " \\addtogroup spa_device\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_device_params_data {
    pub builder: *mut spa_pod_builder,
    pub data: spa_result_device_params,
}
#[test]
fn bindgen_test_layout_spa_result_device_params_data() {
    const UNINIT: ::std::mem::MaybeUninit<spa_result_device_params_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_result_device_params_data>(),
        32usize,
        concat!("Size of: ", stringify!(spa_result_device_params_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_result_device_params_data>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_result_device_params_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).builder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_device_params_data),
            "::",
            stringify!(builder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_device_params_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_node_params_data {
    pub builder: *mut spa_pod_builder,
    pub data: spa_result_node_params,
}
#[test]
fn bindgen_test_layout_spa_result_node_params_data() {
    const UNINIT: ::std::mem::MaybeUninit<spa_result_node_params_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_result_node_params_data>(),
        32usize,
        concat!("Size of: ", stringify!(spa_result_node_params_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_result_node_params_data>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_result_node_params_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).builder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_node_params_data),
            "::",
            stringify!(builder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_result_node_params_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_dsd {
    pub bitorder: spa_param_bitorder,
    pub flags: u32,
    pub interleave: i32,
    pub rate: u32,
    pub channels: u32,
    pub position: [u32; 64usize],
}
#[test]
fn bindgen_test_layout_spa_audio_info_dsd() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_dsd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_dsd>(),
        276usize,
        concat!("Size of: ", stringify!(spa_audio_info_dsd))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_dsd>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_dsd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitorder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_dsd),
            "::",
            stringify!(bitorder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_dsd),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interleave) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_dsd),
            "::",
            stringify!(interleave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_dsd),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_dsd),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_dsd),
            "::",
            stringify!(position)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_dsp {
    pub format: spa_audio_format,
}
#[test]
fn bindgen_test_layout_spa_audio_info_dsp() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_dsp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_dsp>(),
        4usize,
        concat!("Size of: ", stringify!(spa_audio_info_dsp))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_dsp>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_dsp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_dsp),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_vorbis {
    pub rate: u32,
    pub channels: u32,
}
#[test]
fn bindgen_test_layout_spa_audio_info_vorbis() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_vorbis> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_vorbis>(),
        8usize,
        concat!("Size of: ", stringify!(spa_audio_info_vorbis))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_vorbis>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_vorbis))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_vorbis),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_vorbis),
            "::",
            stringify!(channels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_ra {
    pub rate: u32,
    pub channels: u32,
}
#[test]
fn bindgen_test_layout_spa_audio_info_ra() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_ra> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_ra>(),
        8usize,
        concat!("Size of: ", stringify!(spa_audio_info_ra))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_ra>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_ra))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_ra),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_ra),
            "::",
            stringify!(channels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_alac {
    pub rate: u32,
    pub channels: u32,
}
#[test]
fn bindgen_test_layout_spa_audio_info_alac() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_alac> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_alac>(),
        8usize,
        concat!("Size of: ", stringify!(spa_audio_info_alac))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_alac>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_alac))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_alac),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_alac),
            "::",
            stringify!(channels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_flac {
    pub rate: u32,
    pub channels: u32,
}
#[test]
fn bindgen_test_layout_spa_audio_info_flac() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_flac> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_flac>(),
        8usize,
        concat!("Size of: ", stringify!(spa_audio_info_flac))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_flac>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_flac))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_flac),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_flac),
            "::",
            stringify!(channels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_ape {
    pub rate: u32,
    pub channels: u32,
}
#[test]
fn bindgen_test_layout_spa_audio_info_ape() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_ape> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_ape>(),
        8usize,
        concat!("Size of: ", stringify!(spa_audio_info_ape))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_ape>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_ape))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_ape),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_ape),
            "::",
            stringify!(channels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_opus {
    pub rate: u32,
    pub channels: u32,
}
#[test]
fn bindgen_test_layout_spa_audio_info_opus() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info_opus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info_opus>(),
        8usize,
        concat!("Size of: ", stringify!(spa_audio_info_opus))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info_opus>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info_opus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_opus),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info_opus),
            "::",
            stringify!(channels)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spa_audio_info {
    pub media_type: u32,
    pub media_subtype: u32,
    pub info: spa_audio_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spa_audio_info__bindgen_ty_1 {
    pub raw: spa_audio_info_raw,
    pub dsp: spa_audio_info_dsp,
    pub iec958: spa_audio_info_iec958,
    pub dsd: spa_audio_info_dsd,
    pub mp3: spa_audio_info_mp3,
    pub aac: spa_audio_info_aac,
    pub vorbis: spa_audio_info_vorbis,
    pub wma: spa_audio_info_wma,
    pub ra: spa_audio_info_ra,
    pub amr: spa_audio_info_amr,
    pub alac: spa_audio_info_alac,
    pub flac: spa_audio_info_flac,
    pub ape: spa_audio_info_ape,
    pub opus: spa_audio_info_ape,
}
#[test]
fn bindgen_test_layout_spa_audio_info__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info__bindgen_ty_1>(),
        276usize,
        concat!("Size of: ", stringify!(spa_audio_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(dsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iec958) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(iec958)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(dsd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mp3) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(mp3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(aac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vorbis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(vorbis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wma) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(wma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ra) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(ra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).amr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(amr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(alac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(flac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ape) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(ape)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info__bindgen_ty_1),
            "::",
            stringify!(opus)
        )
    );
}
#[test]
fn bindgen_test_layout_spa_audio_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_info>(),
        284usize,
        concat!("Size of: ", stringify!(spa_audio_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_info>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info),
            "::",
            stringify!(media_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_subtype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info),
            "::",
            stringify!(media_subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_info),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_layout_info {
    pub n_channels: u32,
    pub position: [u32; 64usize],
}
#[test]
fn bindgen_test_layout_spa_audio_layout_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_audio_layout_info> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_audio_layout_info>(),
        260usize,
        concat!("Size of: ", stringify!(spa_audio_layout_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_audio_layout_info>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_audio_layout_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_channels) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_layout_info),
            "::",
            stringify!(n_channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_audio_layout_info),
            "::",
            stringify!(position)
        )
    );
}
pub const SPA_H264_STREAM_FORMAT_UNKNOWN: spa_h264_stream_format = 0;
pub const SPA_H264_STREAM_FORMAT_AVC: spa_h264_stream_format = 1;
pub const SPA_H264_STREAM_FORMAT_AVC3: spa_h264_stream_format = 2;
pub const SPA_H264_STREAM_FORMAT_BYTESTREAM: spa_h264_stream_format = 3;
pub type spa_h264_stream_format = ::std::os::raw::c_uint;
pub const SPA_H264_ALIGNMENT_UNKNOWN: spa_h264_alignment = 0;
pub const SPA_H264_ALIGNMENT_AU: spa_h264_alignment = 1;
pub const SPA_H264_ALIGNMENT_NAL: spa_h264_alignment = 2;
pub type spa_h264_alignment = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_info_h264 {
    pub size: spa_rectangle,
    pub framerate: spa_fraction,
    pub max_framerate: spa_fraction,
    pub stream_format: spa_h264_stream_format,
    pub alignment: spa_h264_alignment,
}
#[test]
fn bindgen_test_layout_spa_video_info_h264() {
    const UNINIT: ::std::mem::MaybeUninit<spa_video_info_h264> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_video_info_h264>(),
        32usize,
        concat!("Size of: ", stringify!(spa_video_info_h264))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_video_info_h264>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_video_info_h264))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_h264),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_h264),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_framerate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_h264),
            "::",
            stringify!(max_framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_format) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_h264),
            "::",
            stringify!(stream_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_h264),
            "::",
            stringify!(alignment)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_info_mjpg {
    pub size: spa_rectangle,
    pub framerate: spa_fraction,
    pub max_framerate: spa_fraction,
}
#[test]
fn bindgen_test_layout_spa_video_info_mjpg() {
    const UNINIT: ::std::mem::MaybeUninit<spa_video_info_mjpg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_video_info_mjpg>(),
        24usize,
        concat!("Size of: ", stringify!(spa_video_info_mjpg))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_video_info_mjpg>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_video_info_mjpg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_mjpg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).framerate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_mjpg),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_framerate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_mjpg),
            "::",
            stringify!(max_framerate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_info_dsp {
    pub format: spa_video_format,
    pub flags: u32,
    pub modifier: u64,
}
#[test]
fn bindgen_test_layout_spa_video_info_dsp() {
    const UNINIT: ::std::mem::MaybeUninit<spa_video_info_dsp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_video_info_dsp>(),
        16usize,
        concat!("Size of: ", stringify!(spa_video_info_dsp))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_video_info_dsp>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_video_info_dsp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_dsp),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_dsp),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info_dsp),
            "::",
            stringify!(modifier)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spa_video_info {
    pub media_type: u32,
    pub media_subtype: u32,
    pub info: spa_video_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spa_video_info__bindgen_ty_1 {
    pub raw: spa_video_info_raw,
    pub dsp: spa_video_info_dsp,
    pub h264: spa_video_info_h264,
    pub mjpg: spa_video_info_mjpg,
}
#[test]
fn bindgen_test_layout_spa_video_info__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<spa_video_info__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_video_info__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(spa_video_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_video_info__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_video_info__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info__bindgen_ty_1),
            "::",
            stringify!(dsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h264) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info__bindgen_ty_1),
            "::",
            stringify!(h264)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mjpg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info__bindgen_ty_1),
            "::",
            stringify!(mjpg)
        )
    );
}
#[test]
fn bindgen_test_layout_spa_video_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_video_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_video_info>(),
        96usize,
        concat!("Size of: ", stringify!(spa_video_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_video_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_video_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info),
            "::",
            stringify!(media_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).media_subtype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info),
            "::",
            stringify!(media_subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_video_info),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_cpu {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_cpu() {
    const UNINIT: ::std::mem::MaybeUninit<spa_cpu> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_cpu>(),
        32usize,
        concat!("Size of: ", stringify!(spa_cpu))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_cpu>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_cpu))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_cpu),
            "::",
            stringify!(iface)
        )
    );
}
#[doc = " methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_cpu_methods {
    pub version: u32,
    #[doc = " get CPU flags"]
    pub get_flags:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " force CPU flags, use SPA_CPU_FORCE_AUTODETECT to autodetect CPU flags"]
    pub force_flags: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get number of CPU cores"]
    pub get_count:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " get maximum required alignment of data"]
    pub get_max_align:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    pub get_vm_type:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    pub zero_denormals: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            enable: bool,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_cpu_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_cpu_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_cpu_methods>(),
        56usize,
        concat!("Size of: ", stringify!(spa_cpu_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_cpu_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_cpu_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_cpu_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_cpu_methods),
            "::",
            stringify!(get_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_cpu_methods),
            "::",
            stringify!(force_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_cpu_methods),
            "::",
            stringify!(get_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_max_align) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_cpu_methods),
            "::",
            stringify!(get_max_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_vm_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_cpu_methods),
            "::",
            stringify!(get_vm_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zero_denormals) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_cpu_methods),
            "::",
            stringify!(zero_denormals)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_system {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_system() {
    const UNINIT: ::std::mem::MaybeUninit<spa_system> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_system>(),
        32usize,
        concat!("Size of: ", stringify!(spa_system))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_system>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_system))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system),
            "::",
            stringify!(iface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_poll_event {
    pub events: u32,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_poll_event() {
    const UNINIT: ::std::mem::MaybeUninit<spa_poll_event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_poll_event>(),
        16usize,
        concat!("Size of: ", stringify!(spa_poll_event))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_poll_event>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_poll_event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_poll_event),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_poll_event),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_system_methods {
    pub version: u32,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *mut ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *const ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            request: ::std::os::raw::c_ulong,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            value: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_getres: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            res: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_add: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_mod: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_del: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_wait: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            ev: *mut spa_poll_event,
            n_ev: ::std::os::raw::c_int,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_settime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
            new_value: *const itimerspec,
            old_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            curr_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            expirations: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            signal: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_system_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_system_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_system_methods>(),
        168usize,
        concat!("Size of: ", stringify!(spa_system_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_system_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_system_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ioctl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(ioctl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock_gettime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(clock_gettime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock_getres) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(clock_getres)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollfd_create) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(pollfd_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollfd_add) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(pollfd_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollfd_mod) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(pollfd_mod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollfd_del) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(pollfd_del)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollfd_wait) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(pollfd_wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timerfd_create) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(timerfd_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timerfd_settime) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(timerfd_settime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timerfd_gettime) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(timerfd_gettime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timerfd_read) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(timerfd_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventfd_create) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(eventfd_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventfd_write) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(eventfd_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventfd_read) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(eventfd_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalfd_create) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(signalfd_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signalfd_read) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_system_methods),
            "::",
            stringify!(signalfd_read)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_loop() {
    const UNINIT: ::std::mem::MaybeUninit<spa_loop> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_loop>(),
        32usize,
        concat!("Size of: ", stringify!(spa_loop))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_loop>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_loop))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop),
            "::",
            stringify!(iface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_control {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_loop_control() {
    const UNINIT: ::std::mem::MaybeUninit<spa_loop_control> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_loop_control>(),
        32usize,
        concat!("Size of: ", stringify!(spa_loop_control))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_loop_control>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_loop_control))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control),
            "::",
            stringify!(iface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_utils {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_loop_utils() {
    const UNINIT: ::std::mem::MaybeUninit<spa_loop_utils> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_loop_utils>(),
        32usize,
        concat!("Size of: ", stringify!(spa_loop_utils))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_loop_utils>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_loop_utils))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils),
            "::",
            stringify!(iface)
        )
    );
}
pub type spa_source_func_t = ::std::option::Option<unsafe extern "C" fn(source: *mut spa_source)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_source {
    pub loop_: *mut spa_loop,
    pub func: spa_source_func_t,
    pub data: *mut ::std::os::raw::c_void,
    pub fd: ::std::os::raw::c_int,
    pub mask: u32,
    pub rmask: u32,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_source() {
    const UNINIT: ::std::mem::MaybeUninit<spa_source> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_source>(),
        48usize,
        concat!("Size of: ", stringify!(spa_source))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_source>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_source))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_source),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_source),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_source),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_source),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_source),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rmask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_source),
            "::",
            stringify!(rmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_source),
            "::",
            stringify!(priv_)
        )
    );
}
pub type spa_invoke_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        loop_: *mut spa_loop,
        async_: bool,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Register sources and work items to an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_methods {
    pub version: u32,
    #[doc = " add a source to the loop"]
    pub add_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " update the source io mask"]
    pub update_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " remove a source from the loop"]
    pub remove_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " invoke a function in the context of this loop"]
    pub invoke: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_invoke_func_t,
            seq: u32,
            data: *const ::std::os::raw::c_void,
            size: usize,
            block: bool,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_loop_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_loop_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_loop_methods>(),
        40usize,
        concat!("Size of: ", stringify!(spa_loop_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_loop_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_loop_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_source) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_methods),
            "::",
            stringify!(add_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_source) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_methods),
            "::",
            stringify!(update_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_source) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_methods),
            "::",
            stringify!(remove_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invoke) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_methods),
            "::",
            stringify!(invoke)
        )
    );
}
#[doc = " Control hooks. These hooks can't be removed from their\n  callbacks and must be removed from a safe place (when the loop\n  is not running or when it is locked)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_control_hooks {
    pub version: u32,
    #[doc = " Executed right before waiting for events. It is typically used to\n release locks."]
    pub before: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Executed right after waiting for events. It is typically used to\n reacquire locks."]
    pub after: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_spa_loop_control_hooks() {
    const UNINIT: ::std::mem::MaybeUninit<spa_loop_control_hooks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_loop_control_hooks>(),
        24usize,
        concat!("Size of: ", stringify!(spa_loop_control_hooks))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_loop_control_hooks>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_loop_control_hooks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_hooks),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).before) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_hooks),
            "::",
            stringify!(before)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).after) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_hooks),
            "::",
            stringify!(after)
        )
    );
}
#[doc = " Control an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_control_methods {
    pub version: u32,
    pub get_fd: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    #[doc = " Add a hook\n \\param ctrl the control to change\n \\param hooks the hooks to add\n\n Adds hooks to the loop controlled by \\a ctrl."]
    pub add_hook: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            hook: *mut spa_hook,
            hooks: *const spa_loop_control_hooks,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Enter a loop\n \\param ctrl the control\n\n Start an iteration of the loop. This function should be called\n before calling iterate and is typically used to capture the thread\n that this loop will run in."]
    pub enter: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Leave a loop\n \\param ctrl the control\n\n Ends the iteration of a loop. This should be called after calling\n iterate."]
    pub leave: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Perform one iteration of the loop.\n \\param ctrl the control\n \\param timeout an optional timeout in milliseconds.\n\t0 for no timeout, -1 for infinite timeout.\n\n This function will block\n up to \\a timeout milliseconds and then dispatch the fds with activity.\n The number of dispatched fds is returned."]
    pub iterate: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Check context of the loop\n \\param ctrl the control\n\n This function will check if the current thread is currently the\n one that did the enter call. Since version 1:1.\n\n returns 1 on success, 0 or negative errno value on error."]
    pub check: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_loop_control_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_loop_control_methods> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_loop_control_methods>(),
        56usize,
        concat!("Size of: ", stringify!(spa_loop_control_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_loop_control_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_loop_control_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_methods),
            "::",
            stringify!(get_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_hook) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_methods),
            "::",
            stringify!(add_hook)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_methods),
            "::",
            stringify!(enter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leave) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_methods),
            "::",
            stringify!(leave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iterate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_methods),
            "::",
            stringify!(iterate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_control_methods),
            "::",
            stringify!(check)
        )
    );
}
pub type spa_source_io_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, fd: ::std::os::raw::c_int, mask: u32),
>;
pub type spa_source_idle_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
pub type spa_source_event_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, count: u64)>;
pub type spa_source_timer_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, expirations: u64),
>;
pub type spa_source_signal_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, signal_number: ::std::os::raw::c_int),
>;
#[doc = " Create sources for an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_utils_methods {
    pub version: u32,
    pub add_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            mask: u32,
            close: bool,
            func: spa_source_io_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            mask: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            enabled: bool,
            func: spa_source_idle_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub enable_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            enabled: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_event_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub signal_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_timer_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            value: *mut timespec,
            interval: *mut timespec,
            absolute: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_signal: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal_number: ::std::os::raw::c_int,
            func: spa_source_signal_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    #[doc = " destroy a source allocated with this interface. This function\n should only be called when the loop is not running or from the\n context of the running loop"]
    pub destroy_source: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, source: *mut spa_source),
    >,
}
#[test]
fn bindgen_test_layout_spa_loop_utils_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_loop_utils_methods> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_loop_utils_methods>(),
        88usize,
        concat!("Size of: ", stringify!(spa_loop_utils_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_loop_utils_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_loop_utils_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_io) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(add_io)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_io) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(update_io)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_idle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(add_idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable_idle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(enable_idle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_event) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(add_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_event) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(signal_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_timer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(add_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_timer) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(update_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_signal) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(add_signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy_source) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_loop_utils_methods),
            "::",
            stringify!(destroy_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dbus {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_dbus() {
    const UNINIT: ::std::mem::MaybeUninit<spa_dbus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_dbus>(),
        32usize,
        concat!("Size of: ", stringify!(spa_dbus))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_dbus>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_dbus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus),
            "::",
            stringify!(iface)
        )
    );
}
#[doc = "< The login session bus"]
pub const SPA_DBUS_TYPE_SESSION: spa_dbus_type = 0;
#[doc = "< The systemwide bus"]
pub const SPA_DBUS_TYPE_SYSTEM: spa_dbus_type = 1;
#[doc = "< The bus that started us, if any"]
pub const SPA_DBUS_TYPE_STARTER: spa_dbus_type = 2;
pub type spa_dbus_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dbus_connection_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub disconnected:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_spa_dbus_connection_events() {
    const UNINIT: ::std::mem::MaybeUninit<spa_dbus_connection_events> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_dbus_connection_events>(),
        24usize,
        concat!("Size of: ", stringify!(spa_dbus_connection_events))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_dbus_connection_events>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_dbus_connection_events))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_connection_events),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_connection_events),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnected) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_connection_events),
            "::",
            stringify!(disconnected)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dbus_connection {
    pub version: u32,
    #[doc = " Get the DBusConnection from a wrapper\n\n Note that the returned handle is closed and unref'd by spa_dbus\n immediately before emitting the asynchronous \"disconnected\" event.\n The caller must either deal with the invalidation, or keep an extra\n ref on the handle returned.\n\n \\param conn the spa_dbus_connection wrapper\n \\return a pointer of type DBusConnection"]
    pub get: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut spa_dbus_connection) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroy a dbus connection wrapper\n\n \\param conn the wrapper to destroy"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(conn: *mut spa_dbus_connection)>,
    #[doc = " Add a listener for events\n\n Since version 1"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut spa_dbus_connection,
            listener: *mut spa_hook,
            events: *const spa_dbus_connection_events,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_spa_dbus_connection() {
    const UNINIT: ::std::mem::MaybeUninit<spa_dbus_connection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_dbus_connection>(),
        32usize,
        concat!("Size of: ", stringify!(spa_dbus_connection))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_dbus_connection>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_dbus_connection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_connection),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_connection),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_connection),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_listener) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_connection),
            "::",
            stringify!(add_listener)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dbus_methods {
    pub version: u32,
    #[doc = " Get a new connection wrapper for the given bus type.\n\n The connection wrapper is completely configured to operate\n in the main context of the handle that manages the spa_dbus\n interface.\n\n \\param dbus the dbus manager\n \\param type the bus type to wrap\n \\param error location for the DBusError\n \\return a new dbus connection wrapper or NULL on error"]
    pub get_connection: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            type_: spa_dbus_type,
        ) -> *mut spa_dbus_connection,
    >,
}
#[test]
fn bindgen_test_layout_spa_dbus_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_dbus_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_dbus_methods>(),
        16usize,
        concat!("Size of: ", stringify!(spa_dbus_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_dbus_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_dbus_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_connection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_dbus_methods),
            "::",
            stringify!(get_connection)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_i18n {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_i18n() {
    const UNINIT: ::std::mem::MaybeUninit<spa_i18n> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_i18n>(),
        32usize,
        concat!("Size of: ", stringify!(spa_i18n))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_i18n>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_i18n))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_i18n),
            "::",
            stringify!(iface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_i18n_methods {
    pub version: u32,
    #[doc = " Translate a message\n\n \\param object the i18n interface\n \\param msgid the message\n \\return a translated message"]
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            msgid: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Translate a message for a number\n\n \\param object the i18n interface\n \\param msgid the message to translate\n \\param msgid_plural the plural form of \\a msgid\n \\param n a number\n \\return a translated message for the number \\a n"]
    pub ntext: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            msgid: *const ::std::os::raw::c_char,
            msgid_plural: *const ::std::os::raw::c_char,
            n: ::std::os::raw::c_ulong,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout_spa_i18n_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_i18n_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_i18n_methods>(),
        24usize,
        concat!("Size of: ", stringify!(spa_i18n_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_i18n_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_i18n_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_i18n_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_i18n_methods),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ntext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_i18n_methods),
            "::",
            stringify!(ntext)
        )
    );
}
pub const SPA_LOG_LEVEL_NONE: spa_log_level = 0;
pub const SPA_LOG_LEVEL_ERROR: spa_log_level = 1;
pub const SPA_LOG_LEVEL_WARN: spa_log_level = 2;
pub const SPA_LOG_LEVEL_INFO: spa_log_level = 3;
pub const SPA_LOG_LEVEL_DEBUG: spa_log_level = 4;
pub const SPA_LOG_LEVEL_TRACE: spa_log_level = 5;
pub type spa_log_level = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_log {
    pub iface: spa_interface,
    #[doc = " Logging level, everything above this level is not logged"]
    pub level: spa_log_level,
}
#[test]
fn bindgen_test_layout_spa_log() {
    const UNINIT: ::std::mem::MaybeUninit<spa_log> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_log>(),
        40usize,
        concat!("Size of: ", stringify!(spa_log))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_log>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_log))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log),
            "::",
            stringify!(iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log),
            "::",
            stringify!(level)
        )
    );
}
#[doc = " \\struct spa_log_topic\n\n Identifier for a topic. Topics are string-based filters that logically\n group messages together. An implementation may decide to filter different\n topics on different levels, for example the \"protocol\" topic may require\n debug level TRACE while the \"core\" topic defaults to debug level INFO.\n\n spa_log_topics require a spa_log_methods version of 1 or higher."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_log_topic {
    #[doc = " the version of this topic. This can be used to expand this\n structure in the future"]
    pub version: u32,
    #[doc = " The string identifier for the topic"]
    pub topic: *const ::std::os::raw::c_char,
    #[doc = " Logging level set for this topic"]
    pub level: spa_log_level,
    #[doc = " False if this topic follows the \\ref spa_log level"]
    pub has_custom_level: bool,
}
#[test]
fn bindgen_test_layout_spa_log_topic() {
    const UNINIT: ::std::mem::MaybeUninit<spa_log_topic> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_log_topic>(),
        24usize,
        concat!("Size of: ", stringify!(spa_log_topic))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_log_topic>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_log_topic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_topic),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_topic),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_topic),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_custom_level) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_topic),
            "::",
            stringify!(has_custom_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_log_methods {
    pub version: u32,
    #[doc = " Log a message with the given log level.\n\n \\note If compiled with this header, this function is only called\n for implementations of version 0. For versions 1 and above, see\n logt() instead.\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param ... format arguments"]
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level.\n\n \\note If compiled with this header, this function is only called\n for implementations of version 0. For versions 1 and above, see\n logtv() instead.\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param args format arguments"]
    pub logv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
    #[doc = " Log a message with the given log level for the given topic.\n\n \\note Callers that do not use topic-based logging (version 0), the \\a\n topic is NULL\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param topic the topic for this message, may be NULL\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param ... format arguments\n\n \\since 1"]
    pub logt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            topic: *const spa_log_topic,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level for the given topic.\n\n \\note For callers that do not use topic-based logging (version 0),\n the \\a topic is NULL\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param topic the topic for this message, may be NULL\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param args format arguments\n\n \\since 1"]
    pub logtv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            topic: *const spa_log_topic,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
    #[doc = " Initializes a \\ref spa_log_topic to the correct logging level.\n\n \\since 1"]
    pub topic_init: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, topic: *mut spa_log_topic),
    >,
}
#[test]
fn bindgen_test_layout_spa_log_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_log_methods> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_log_methods>(),
        48usize,
        concat!("Size of: ", stringify!(spa_log_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_log_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_log_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_methods),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logv) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_methods),
            "::",
            stringify!(logv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_methods),
            "::",
            stringify!(logt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logtv) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_methods),
            "::",
            stringify!(logtv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic_init) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_log_methods),
            "::",
            stringify!(topic_init)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_plugin_loader {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_plugin_loader() {
    const UNINIT: ::std::mem::MaybeUninit<spa_plugin_loader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_plugin_loader>(),
        32usize,
        concat!("Size of: ", stringify!(spa_plugin_loader))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_plugin_loader>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_plugin_loader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_plugin_loader),
            "::",
            stringify!(iface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_plugin_loader_methods {
    pub version: u32,
    #[doc = " Load a SPA plugin.\n\n \\param factory_name Plugin factory name\n \\param info Info dictionary for plugin. NULL if none.\n \\return plugin handle, or NULL on error"]
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            factory_name: *const ::std::os::raw::c_char,
            info: *const spa_dict,
        ) -> *mut spa_handle,
    >,
    #[doc = " Unload a SPA plugin.\n\n \\param handle Plugin handle.\n \\return 0 on success, < 0 on error"]
    pub unload: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            handle: *mut spa_handle,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_plugin_loader_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_plugin_loader_methods> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_plugin_loader_methods>(),
        24usize,
        concat!("Size of: ", stringify!(spa_plugin_loader_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_plugin_loader_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_plugin_loader_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_plugin_loader_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_plugin_loader_methods),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unload) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_plugin_loader_methods),
            "::",
            stringify!(unload)
        )
    );
}
#[doc = " \\addtogroup spa_handle\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_handle {
    pub version: u32,
    #[doc = " Get the interface provided by \\a handle with \\a type.\n\n \\a interface is always a struct spa_interface but depending on\n \\a type, the struct might contain other information.\n\n \\param handle a spa_handle\n \\param type the interface type\n \\param interface result to hold the interface.\n \\return 0 on success\n         -ENOTSUP when there are no interfaces\n         -EINVAL when handle or info is NULL"]
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut spa_handle,
            type_: *const ::std::os::raw::c_char,
            interface: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Clean up the memory of \\a handle. After this, \\a handle should not be used\n anymore.\n\n \\param handle a pointer to memory\n \\return 0 on success"]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut spa_handle) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_handle() {
    const UNINIT: ::std::mem::MaybeUninit<spa_handle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_handle>(),
        24usize,
        concat!("Size of: ", stringify!(spa_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_handle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle),
            "::",
            stringify!(get_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle),
            "::",
            stringify!(clear)
        )
    );
}
#[doc = " This structure lists the information about available interfaces on\n handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_interface_info {
    pub type_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_spa_interface_info() {
    const UNINIT: ::std::mem::MaybeUninit<spa_interface_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_interface_info>(),
        8usize,
        concat!("Size of: ", stringify!(spa_interface_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_interface_info>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_interface_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_interface_info),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " Extra supporting infrastructure passed to the init() function of\n a factory. It can be extra information or interfaces such as logging."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_support {
    pub type_: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spa_support() {
    const UNINIT: ::std::mem::MaybeUninit<spa_support> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_support>(),
        16usize,
        concat!("Size of: ", stringify!(spa_support))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_support>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_support))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_support),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_support),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_handle_factory {
    pub version: u32,
    #[doc = " The name of the factory contains a logical name that describes\n the function of the handle. Other plugins might contain an alternative\n implementation with the same name.\n\n See utils/names.h for the list of standard names.\n\n Examples include:\n\n  api.alsa.pcm.sink: an object to write PCM samples to an alsa PLAYBACK\n\t\t\tdevice\n  api.v4l2.source: an object to read from a v4l2 source."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Extra information about the handles of this factory."]
    pub info: *const spa_dict,
    #[doc = " Get the size of handles from this factory.\n\n \\param factory a spa_handle_factory\n \\param params extra parameters that determine the size of the\n handle."]
    pub get_size: ::std::option::Option<
        unsafe extern "C" fn(factory: *const spa_handle_factory, params: *const spa_dict) -> usize,
    >,
    #[doc = " Initialize an instance of this factory. The caller should allocate\n memory at least size bytes and pass this as \\a handle.\n\n \\a support can optionally contain extra interfaces or data items that the\n plugin can use such as a logger.\n\n \\param factory a spa_handle_factory\n \\param handle a pointer to memory\n \\param info extra handle specific information, usually obtained\n        from a spa_device. This can be used to configure the handle.\n \\param support support items\n \\param n_support number of elements in \\a support\n \\return 0 on success\n\t   < 0 errno type error"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            handle: *mut spa_handle,
            info: *const spa_dict,
            support: *const spa_support,
            n_support: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " spa_handle_factory::enum_interface_info:\n \\param factory: a #spa_handle_factory\n \\param info: result to hold spa_interface_info.\n \\param index: index to keep track of the enumeration, 0 for first item\n\n Enumerate the interface information for \\a factory.\n\n \\return 1 when an item is available\n\t   0 when no more items are available\n\t   < 0 errno type error"]
    pub enum_interface_info: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            info: *mut *const spa_interface_info,
            index: *mut u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_handle_factory() {
    const UNINIT: ::std::mem::MaybeUninit<spa_handle_factory> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_handle_factory>(),
        48usize,
        concat!("Size of: ", stringify!(spa_handle_factory))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_handle_factory>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_handle_factory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle_factory),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle_factory),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle_factory),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle_factory),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle_factory),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enum_interface_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_handle_factory),
            "::",
            stringify!(enum_interface_info)
        )
    );
}
#[doc = " The function signature of the entry point in a plugin.\n\n \\param factory a location to hold the factory result\n \\param index index to keep track of the enumeration\n \\return 1 on success\n         0 when there are no more factories\n         -EINVAL when factory is NULL"]
pub type spa_handle_factory_enum_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " The entry point in a plugin.\n\n \\param factory a location to hold the factory result\n \\param index index to keep track of the enumeration\n \\return 1 on success\n\t   0 when no more items are available\n\t   < 0 errno type error"]
    pub fn spa_handle_factory_enum(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_thread_utils {
    pub iface: spa_interface,
}
#[test]
fn bindgen_test_layout_spa_thread_utils() {
    const UNINIT: ::std::mem::MaybeUninit<spa_thread_utils> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_thread_utils>(),
        32usize,
        concat!("Size of: ", stringify!(spa_thread_utils))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_thread_utils>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_thread_utils))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_thread_utils),
            "::",
            stringify!(iface)
        )
    );
}
#[doc = " thread utils"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_thread_utils_methods {
    pub version: u32,
    #[doc = " create a new thread that runs \\a start with \\a arg"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
            start: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                ) -> *mut ::std::os::raw::c_void,
            >,
            arg: *mut ::std::os::raw::c_void,
        ) -> *mut spa_thread,
    >,
    #[doc = " stop and join a thread"]
    pub join: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
            retval: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get realtime priority range for threads created with \\a props"]
    pub get_rt_range: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
            min: *mut ::std::os::raw::c_int,
            max: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " acquire realtime priority, a priority of -1 refers to the priority\n configured in the realtime module"]
    pub acquire_rt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
            priority: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " drop realtime priority"]
    pub drop_rt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_spa_thread_utils_methods() {
    const UNINIT: ::std::mem::MaybeUninit<spa_thread_utils_methods> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_thread_utils_methods>(),
        48usize,
        concat!("Size of: ", stringify!(spa_thread_utils_methods))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_thread_utils_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_thread_utils_methods))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_thread_utils_methods),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_thread_utils_methods),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).join) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_thread_utils_methods),
            "::",
            stringify!(join)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_rt_range) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_thread_utils_methods),
            "::",
            stringify!(get_rt_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire_rt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_thread_utils_methods),
            "::",
            stringify!(acquire_rt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drop_rt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_thread_utils_methods),
            "::",
            stringify!(drop_rt)
        )
    );
}
#[doc = " \\addtogroup spa_json\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_json {
    pub cur: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub parent: *mut spa_json,
    pub state: u32,
    pub depth: u32,
}
#[test]
fn bindgen_test_layout_spa_json() {
    const UNINIT: ::std::mem::MaybeUninit<spa_json> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_json>(),
        32usize,
        concat!("Size of: ", stringify!(spa_json))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_json>(),
        8usize,
        concat!("Alignment of ", stringify!(spa_json))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_json),
            "::",
            stringify!(cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_json),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_json),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_json),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_json),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = " \\addtogroup spa_ringbuffer\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_ringbuffer {
    pub readindex: u32,
    pub writeindex: u32,
}
#[test]
fn bindgen_test_layout_spa_ringbuffer() {
    const UNINIT: ::std::mem::MaybeUninit<spa_ringbuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spa_ringbuffer>(),
        8usize,
        concat!("Size of: ", stringify!(spa_ringbuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<spa_ringbuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(spa_ringbuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_ringbuffer),
            "::",
            stringify!(readindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writeindex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spa_ringbuffer),
            "::",
            stringify!(writeindex)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
